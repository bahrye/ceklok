// Code.gs

// Variabel global untuk nama sheet
const KALENDER_SHEET_NAME = "Kalender_Pendidikan";
const USERS_SHEET_NAME = "Users"; // Kolom: A=Username, B=Password, C=Role, D=Nama_Guru_Asli, E=GoogleEmail
const NAMA_GURU_SHEET_NAME = "Nama_Guru"; // Kolom: A=Nama Guru
const SETTING_SHEET_NAME = "Setting"; // Sel A1: BulanTahun (mm/yyyy) -> Ini akan menjadi batas bawah periode ceklok
const CEKLOK_MANUAL_SHEET_NAME = "Ceklok_Manual";
const HASIL_CEKLOK_SHEET_NAME = "Hasil_Ceklok";
const CETAK_SHEET_NAME = "CETAK"; // Untuk PDF
const LOGIN_HISTORY_SHEET_NAME = "Login_History";
const OPSIKETLIBUR_SHEET_NAME = "Opsi_Keterangan_Libur";
const LOCK_ID_SHEET_NAME = "LOCK_ID";
const TEMPLATE_SHEET_FOR_BACKUP = "Worksheet";
const BACKUP_SHEET_PREFIX = "Worksheet_";
const WORKSHEET_NAME = "Worksheet";
const TEMP_SHEET_PREFIX = "CetakSementara_";
const CETAK_TEMPLATE_SHEET_NAME = "CETAK";

const PRIMARY_EMAIL_OTP_EXPIRY_MINUTES = 10;
const CHANGE_EMAIL_OTP_EXPIRY_MINUTES_GS = 10;
const PASSWORD_RESET_OTP_EXPIRY_MINUTES_GS = 10;

const REMINDER_LOG_SHEET_NAME = "Reminder_Log";
const EMAIL_SENDER_NAME = "Admin Ceklok MTS Tanuntung";

const LOCKED_MONTHS_SHEET_NAME = "Locked_Months";

// Konstanta untuk Peran Pengguna
const ROLE_SUPERADMIN = "superadmin";
const ROLE_ADMIN = "admin";
const ROLE_USER = "user";

const ACTIVITY_LOG_SHEET_NAME = "Activity_Log"; // Nama untuk sheet log baru

const USERNAME_CHANGE_REQUESTS_SHEET_NAME = "UsernameChangeRequests";

const CONFIG_SHEET_NAME = "Setting";

const ss = SpreadsheetApp.getActiveSpreadsheet();


function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('Ceklok Guru MTS TANUNTUNG')
    .setFaviconUrl("https://i.imgur.com/CmVVVxB.png")
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

function getHtmlContent(filename) {
  try {
    return HtmlService.createHtmlOutputFromFile(filename).getContent();
  } catch (e) {
    Logger.log("Error Gagal memuat file HTML '" + filename + "': " + e.toString());
    return "<p style='color:red;'>Error: Konten untuk '" + filename + "' tidak dapat dimuat. Pastikan file ada.</p>";
  }
}

function getCeklokInputSettings() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const settingSheet = ss.getSheetByName(SETTING_SHEET_NAME);
    if (!settingSheet) {
      return { success: false, error: `Sheet '${SETTING_SHEET_NAME}' tidak ditemukan.` };
    }
    const adminDefinedMinMonthYear = settingSheet.getRange('A1').getDisplayValue();
    if (!adminDefinedMinMonthYear || !/^\d{2}\/\d{4}$/.test(adminDefinedMinMonthYear)) {
      return { success: false, error: "Format bulan/tahun di Setting A1 (batas bawah admin) tidak valid (mm/yyyy)." };
    }

    const now = new Date();
    const serverCurrentMonthYear = Utilities.formatDate(now, Session.getScriptTimeZone(), "MM/yyyy");

    return {
      success: true,
      adminDefinedMinMonthYear: adminDefinedMinMonthYear,
      serverCurrentMonthYear: serverCurrentMonthYear
    };
  } catch (e) {
    Logger.log(`Error di getCeklokInputSettings: ${e.toString()}`);
    return { success: false, error: `Gagal mengambil pengaturan input ceklok: ${e.message}` };
  }
}


function setBulanTahunSetting(newBulanTahun, actingUserUsername, actingUserRole) {
  try {
    if (!newBulanTahun || typeof newBulanTahun !== 'string' || !/^\d{2}\/\d{4}$/.test(newBulanTahun)) {
      logUserActivity(actingUserUsername, actingUserRole, "SET_GLOBAL_MONTH_FAIL", newBulanTahun, "Format Bulan/Tahun tidak valid (mm/yyyy)", "FAIL");
      return { success: false, error: "Format Bulan/Tahun tidak valid. Harap gunakan format mm/yyyy (contoh: 05/2025)." };
    }
    const [mmStr, yyyyStr] = newBulanTahun.split("/");
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(yyyyStr, 10);

    if (isNaN(mm) || isNaN(yyyy) || mm < 1 || mm > 12 || yyyy < 2000 || yyyy > 2199) {
      logUserActivity(actingUserUsername, actingUserRole, "SET_GLOBAL_MONTH_FAIL", newBulanTahun, "Nilai Bulan/Tahun tidak valid (range)", "FAIL");
      return { success: false, error: "Nilai Bulan/Tahun tidak valid. Gunakan mm/yyyy (tahun 2000-2199)." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const settingSheet = ss.getSheetByName(SETTING_SHEET_NAME);
    if (!settingSheet) {
      logUserActivity(actingUserUsername, actingUserRole, "SET_GLOBAL_MONTH_ERROR", newBulanTahun, `Sheet '${SETTING_SHEET_NAME}' tidak ditemukan`, "ERROR");
      return { success: false, error: `Sheet '${SETTING_SHEET_NAME}' tidak ditemukan.` };
    }

    const oldValue = settingSheet.getRange('A1').getDisplayValue(); // <-- AMBIL NILAI LAMA DI SINI

    settingSheet.getRange('A1').setValue(newBulanTahun);
    logUserActivity(actingUserUsername, actingUserRole, "SET_GLOBAL_MONTH_SUCCESS", newBulanTahun, `Nilai lama: ${oldValue}, Nilai baru: ${newBulanTahun}`, "SUCCESS"); // <-- SEKARANG oldValue TERDEFINISI
    return { success: true, message: `Batas Bawah Periode Ceklok berhasil diubah menjadi ${newBulanTahun}.`, newBulanTahun: newBulanTahun };
  } catch (e) {
    Logger.log(`Error di setBulanTahunSetting: ${e.toString()}; Input: ${newBulanTahun}`);
    logUserActivity(actingUserUsername, actingUserRole, "SET_GLOBAL_MONTH_ERROR", newBulanTahun, e.message, "ERROR");
    return { success: false, error: `Gagal mengubah Batas Bawah Periode Ceklok: ${e.message}` };
  }
}

function verifyLogin(usernameFromInput, password) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const passwordColIdx = headers.indexOf("password");
    const roleColIdx = headers.indexOf("role");
    const teacherNameColIdx = headers.indexOf("nama_guru_asli");
    const googleEmailColIdx = headers.indexOf("googleemail");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1 || passwordColIdx === -1 || roleColIdx === -1 || primaryEmailColIdx === -1) {
        let missingCols = [];
        if (usernameColIdx === -1) missingCols.push("Username");
        if (passwordColIdx === -1) missingCols.push("Password");
        if (roleColIdx === -1) missingCols.push("Role");
        if (primaryEmailColIdx === -1) missingCols.push("PrimaryEmail");
        return { success: false, error: `Struktur kolom di sheet Users tidak lengkap. Kolom yang hilang: ${missingCols.join(', ')}.` };
    }

    const inputIsEmailFormat = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(usernameFromInput.toLowerCase());
    let userRowData = null;

    for (let i = 1; i < data.length; i++) {
      const currentRow = data[i];
      const sheetUsername = currentRow[usernameColIdx] ? String(currentRow[usernameColIdx]).trim() : "";
      const sheetPrimaryEmail = currentRow[primaryEmailColIdx] ? String(currentRow[primaryEmailColIdx]).trim() : "";
      const sheetPassword = currentRow[passwordColIdx] ? String(currentRow[passwordColIdx]) : "";

      let match = false;
      if (inputIsEmailFormat) {
        if (sheetPrimaryEmail.toLowerCase() === usernameFromInput.toLowerCase()) {
          match = true;
        } else if (sheetUsername.toLowerCase() === usernameFromInput.toLowerCase()) {
          match = true;
        }
      } else {
        if (sheetUsername.toLowerCase() === usernameFromInput.toLowerCase()) {
          match = true;
        }
      }

      if (match && sheetPassword === password) {
        userRowData = currentRow;
        break;
      }
    }

    if (userRowData) {
      const actualUsername = String(userRowData[usernameColIdx]).trim();
      const role = String(userRowData[roleColIdx]).trim();
      const actualTeacherName = (teacherNameColIdx > -1 && userRowData[teacherNameColIdx]) ? String(userRowData[teacherNameColIdx]).trim() : "";
      const googleEmail = (googleEmailColIdx > -1 && userRowData[googleEmailColIdx]) ? String(userRowData[googleEmailColIdx]).trim() : null;
      const primaryEmail = (primaryEmailColIdx > -1 && userRowData[primaryEmailColIdx]) ? String(userRowData[primaryEmailColIdx]).trim() : null;

      let effectiveTeacherName = null;
      if (role === ROLE_USER) { // Menggunakan konstanta
        if (!actualTeacherName) {
          logUserActivity(actualUsername, role, "LOGIN_PASSWORD_WARN", actualUsername, "Nama_Guru_Asli kosong", "WARN");
          return { success: false, error: `Login berhasil untuk '${actualUsername}', tetapi 'Nama_Guru_Asli' kosong. Hubungi admin.` };
        }
        effectiveTeacherName = actualTeacherName;
        const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
        if (sheetGuru) {
            const guruList = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
            if (!guruList.includes(effectiveTeacherName)) {
              logUserActivity(actualUsername, role, "LOGIN_PASSWORD_WARN", actualUsername, `Nama Guru Asli '${effectiveTeacherName}' tidak valid`, "WARN");
            return { success: false, error: `Nama Guru Asli '${effectiveTeacherName}' (user: ${actualUsername}) tidak ada di sheet '${NAMA_GURU_SHEET_NAME}'.` };
            }
        } else {
            Logger.log(`Peringatan: Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan saat validasi login user.`);
        }
      }

      try {
          let loginHistorySheet = ensureSheet(LOGIN_HISTORY_SHEET_NAME, ["Username", "Login_Timestamp", "Nama_Guru", "Metode_Login"]);
          const timestamp = new Date();
          loginHistorySheet.appendRow([actualUsername, timestamp, effectiveTeacherName || '', "Password"]);
          logUserActivity(actualUsername, role, "LOGIN_PASSWORD_SUCCESS", actualUsername, `Role: ${role}`, "SUCCESS");
      } catch (logError) {
          Logger.log(`Gagal mencatat histori login untuk ${actualUsername}: ${logError.toString()}`);
      }
      
      return {
          success: true,
          username: actualUsername,
          role: role,
          teacherName: effectiveTeacherName,
          googleEmail: googleEmail,
          primaryEmail: primaryEmail
      };
    } else {
      // === BARU: Log ke Activity_Log untuk login GAGAL ===
      // Kita log username yang dicoba oleh pengguna
      logUserActivity(usernameFromInput, "ANONYMOUS", "LOGIN_PASSWORD_FAIL", usernameFromInput, "Username/Password salah", "FAIL");
      // ===================================================
      return { success: false, error: "Username/Email atau password salah." };
    }
  } catch (e) {
    Logger.log(`Error in verifyLogin: ${e.toString()}; Input: ${usernameFromInput}`);
    // === BARU: Log error sistem saat proses login ===
    logUserActivity(usernameFromInput || "ANONYMOUS", "ANONYMOUS", "LOGIN_SYSTEM_ERROR", usernameFromInput, e.message, "ERROR");
    // ================================================
    return { success: false, error: `Error server saat login: ${e.message}` };
  }
}

function getInitialData() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    const settingSheet = ss.getSheetByName(SETTING_SHEET_NAME);

    if (!sheetGuru) return { error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (!settingSheet) return { error: `Sheet '${SETTING_SHEET_NAME}' (A1: mm/yyyy) tidak ditemukan.` };

    const guruList = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
    const adminMinMonthYear = settingSheet.getRange('A1').getDisplayValue();

    if (!adminMinMonthYear || !/^\d{2}\/\d{4}$/.test(adminMinMonthYear)) {
      return { error: "Format bulan/tahun (batas bawah) di Setting A1 tidak valid (mm/yyyy)." };
    }
    
    ensureSheet(KALENDER_SHEET_NAME, ["Tanggal (dd/mm/yyyy)", "Keterangan"]);

    return { guruList, adminDefinedMinMonthYear: adminMinMonthYear };
  } catch (e) {
      Logger.log(`Error in getInitialData: ${e.toString()}`);
      return { error: `Gagal memuat data awal admin: ${e.message}`};
  }
}

function getCeklokData(nama, bulanTahun) {
  try {
    // 1. Validasi Awal (tetap sama, sudah cukup efisien)
    const settings = getCeklokInputSettings();
    if (settings.error) {
      Logger.log(`getCeklokData: Peringatan - Gagal memuat settings untuk validasi bulan - ${settings.error}`);
    } else {
      // Logika validasi rentang tanggal (tidak diubah)
      const parseMonthYearToDate = (myStr) => {
        if (!myStr || !myStr.includes('/')) return null;
        const [m, y] = myStr.split('/').map(Number);
        return new Date(y, m - 1, 1);
      };
      const requestedDateObj = parseMonthYearToDate(bulanTahun);
      const minDateObj = parseMonthYearToDate(settings.adminDefinedMinMonthYear);
      const maxDateObj = parseMonthYearToDate(settings.serverCurrentMonthYear);
      if (requestedDateObj && minDateObj && requestedDateObj < minDateObj) {
        return { error: `Periode ${bulanTahun} tidak diizinkan. Batas minimum adalah ${settings.adminDefinedMinMonthYear}.` };
      }
      if (requestedDateObj && maxDateObj && requestedDateObj > maxDateObj) {
        return { error: `Periode ${bulanTahun} tidak diizinkan. Batas maksimum adalah ${settings.serverCurrentMonthYear}.` };
      }
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const liburSheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    const opsiKetLiburSheet = ss.getSheetByName(OPSIKETLIBUR_SHEET_NAME);

    if (!sheet || !liburSheet) {
        return { error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' atau '${KALENDER_SHEET_NAME}' tidak ditemukan.` };
    }

    // 2. Baca data libur dan opsi keterangan dalam satu kali operasi
    const liburMap = new Map();
    if (liburSheet.getLastRow() > 1) {
        liburSheet.getRange(2, 1, liburSheet.getLastRow() - 1, 2).getDisplayValues().forEach(([tgl, ket]) => {
            if (tgl) liburMap.set(tgl, ket || 'Hari Libur');
        });
    }
    
    let ketLiburOptions = [];
    if (opsiKetLiburSheet && opsiKetLiburSheet.getLastRow() > 1) {
      ketLiburOptions = opsiKetLiburSheet.getRange(2, 1, opsiKetLiburSheet.getLastRow() - 1, 1).getValues().flat().filter(String).map(o => String(o).trim());
    }

    const [mmStr, yyyyStr] = bulanTahun.split("/");
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(yyyyStr, 10);
    if (isNaN(mm) || isNaN(yyyy)) {
        return { error: "Bulan/Tahun tidak valid." };
    }

    // 3. Buat Peta (Map) dari data ceklok untuk pencarian super cepat
    const allData = sheet.getDataRange().getValues();
    const headers = allData[0].map(h => String(h).trim());
    const namaColIdx = headers.indexOf("Nama_Guru");
    const tanggalColIdx = headers.indexOf("Tanggal");
    const masukColIdx = headers.indexOf("Jam_Masuk");
    const pulangColIdx = headers.indexOf("Jam_Pulang");
    const ketLiburManualColIdx = headers.indexOf("Ket_Libur_Manual");

    if ([namaColIdx, tanggalColIdx, masukColIdx, pulangColIdx].includes(-1)) {
        return { error: "Header di 'Ceklok_Manual' tidak lengkap." };
    }

    const ceklokDataMap = new Map();
    for (let i = 1; i < allData.length; i++) {
        const row = allData[i];
        const guru = String(row[namaColIdx]).trim();
        // Proses hanya data untuk guru yang diminta untuk efisiensi
        if (guru === nama && row[tanggalColIdx] instanceof Date) {
            const tanggal = Utilities.formatDate(new Date(row[tanggalColIdx]), Session.getScriptTimeZone(), "dd/MM/yyyy");
            // Simpan data relevan ke Map
            ceklokDataMap.set(tanggal, {
                jamMasuk: String(row[masukColIdx] || ''),
                jamPulang: String(row[pulangColIdx] || ''),
                ketManual: String(row[ketLiburManualColIdx] || '')
            });
        }
    }

    // 4. Bangun hasil data dengan pencarian cepat dari Map
    const resultData = [];
    const namaHariIndonesia = ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"];
    const lastDay = new Date(yyyy, mm, 0).getDate();

    for (let i = 1; i <= lastDay; i++) {
      const dateObj = new Date(yyyy, mm - 1, i);
      const dateStr = Utilities.formatDate(dateObj, Session.getScriptTimeZone(), "dd/MM/yyyy");
      const hari = namaHariIndonesia[dateObj.getDay()];

      const keteranganKalender = liburMap.get(dateStr) || '';
      const isLiburKalender = (dateObj.getDay() === 0) || (keteranganKalender !== '');
      
      // Ambil data dari Map (operasi ini sangat cepat)
      const dataRow = ceklokDataMap.get(dateStr);

      resultData.push({
        hari,
        tanggal: dateStr,
        dataMasuk: dataRow ? dataRow.jamMasuk : '',
        dataPulang: dataRow ? dataRow.jamPulang : '',
        isLibur: isLiburKalender,
        keterangan: keteranganKalender,
        keteranganLiburManual: dataRow ? dataRow.ketManual : ''
      });
    }

    // Pengecekan status penguncian bulan (tetap sama)
    const lockStatusResult = getLockedMonths();
    let isMonthCurrentlyLocked = false;
    if (lockStatusResult.success) {
      isMonthCurrentlyLocked = (lockStatusResult.months || []).includes(bulanTahun);
    } else {
      Logger.log(`getCeklokData: Peringatan - Gagal memeriksa status kunci bulan ${bulanTahun} - ${lockStatusResult.error}`);
    }

    return { 
      data: resultData, 
      optionsKeteranganLibur: ketLiburOptions, 
      isLocked: isMonthCurrentlyLocked 
    };
  } catch (e) {
    Logger.log(`Error in getCeklokData (Optimized) (Nama: ${nama}, BulanTahun: ${bulanTahun}): ${e.toString()}\nStack: ${e.stack}`);
    return { error: `Gagal mengambil data ceklok: ${e.message}` };
  }
}


function simpanData(nama, dataInput, actorUsername, actorRole) {
  try {
    if (!dataInput || dataInput.length === 0 || !dataInput[0].tanggal) {
      logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_FAIL", nama, "Data input tidak valid (payload)", "FAIL");
      return "Error: Data input tidak valid untuk disimpan.";
    }
    const tanggalPertama = dataInput[0].tanggal;
    const parts = tanggalPertama.split("/");
    if (parts.length !== 3) {
      logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_FAIL", nama, `Format tanggal tidak valid: ${tanggalPertama}`, "FAIL");
      return "Error: Format tanggal pada data input tidak valid.";
    }
    const bulanTahunSimpan = `${parts[1]}/${parts[2]}`;

    // 1. Pengecekan status penguncian bulan (tetap diperlukan)
    const lockStatusResult = getLockedMonths();
    if (lockStatusResult.success && (lockStatusResult.months || []).includes(bulanTahunSimpan)) {
      logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_FAIL", nama, `Penyimpanan ditolak, bulan ${bulanTahunSimpan} terkunci`, "FAIL");
      return `Error: Bulan ${bulanTahunSimpan} telah dikunci oleh Admin dan tidak dapat diubah.`;
    } else if (!lockStatusResult.success) {
      logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_WARN", nama, `Gagal cek status kunci (${bulanTahunSimpan}): ${lockStatusResult.error}. Simpan dilanjutkan.`, "WARN");
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    if (!sheet) {
      logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_ERROR", nama, `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan`, "ERROR");
      return `Error: Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.`;
    }

    // 2. Baca SEMUA data dari sheet ke memori dalam satu kali panggilan
    const dataRange = sheet.getDataRange();
    const allSheetData = dataRange.getValues();
    const headers = allSheetData[0].map(h => String(h).trim());
    
    // Validasi header
    const namaColIdx = headers.indexOf("Nama_Guru");
    const tanggalColIdx = headers.indexOf("Tanggal");
    const masukColIdx = headers.indexOf("Jam_Masuk");
    const pulangColIdx = headers.indexOf("Jam_Pulang");
    const ketLiburManualColIdx = headers.indexOf("Ket_Libur_Manual");
    if ([namaColIdx, tanggalColIdx, masukColIdx, pulangColIdx, ketLiburManualColIdx].includes(-1)) {
        const errorMsg = "Header di 'Ceklok_Manual' tidak lengkap.";
        logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_ERROR", nama, errorMsg, "ERROR");
        return `Error: ${errorMsg}`;
    }

    // 3. Buat sebuah "peta" untuk pencarian data yang sangat cepat
    const dataMap = new Map();
    for (let i = 1; i < allSheetData.length; i++) {
        const row = allSheetData[i];
        const guru = String(row[namaColIdx]).trim();
        if (row[tanggalColIdx] instanceof Date) {
            const tanggal = Utilities.formatDate(new Date(row[tanggalColIdx]), Session.getScriptTimeZone(), "dd/MM/yyyy");
            const key = `${guru}#${tanggal}`; // Kunci unik: NamaGuru#dd/MM/yyyy
            dataMap.set(key, { rowIndex: i, data: row }); // Simpan indeks baris asli dan datanya
        }
    }

    let hasChanges = false;
    const rowsToAppend = [];

    // 4. Proses semua input dari pengguna di dalam memori
    dataInput.forEach(inputRow => {
        if (!inputRow || !inputRow.tanggal) return;

        const { tanggal, jamMasuk, jamPulang, keteranganLiburManual } = inputRow;
        let jmToSave = jamMasuk || "";
        let jpToSave = jamPulang || "";
        const ketLiburToSave = keteranganLiburManual ? String(keteranganLiburManual).trim() : "";

        if (ketLiburToSave !== "") {
            jmToSave = "";
            jpToSave = "";
        }

        const mapKey = `${nama}#${tanggal}`;
        const existingEntry = dataMap.get(mapKey);
        const targetEntityLog = `${nama} (${tanggal})`;

        if (existingEntry) {
            // Jika data sudah ada, modifikasi array 'allSheetData'
            const rowIndex = existingEntry.rowIndex;
            const oldData = existingEntry.data;
            const oldJm = oldData[masukColIdx] ? String(oldData[masukColIdx]).trim() : '';
            const oldJp = oldData[pulangColIdx] ? String(oldData[pulangColIdx]).trim() : '';
            const oldKet = oldData[ketLiburManualColIdx] ? String(oldData[ketLiburManualColIdx]).trim() : '';

            if (oldJm !== jmToSave || oldJp !== jpToSave || oldKet !== ketLiburToSave) {
                allSheetData[rowIndex][masukColIdx] = jmToSave;
                allSheetData[rowIndex][pulangColIdx] = jpToSave;
                allSheetData[rowIndex][ketLiburManualColIdx] = ketLiburToSave;
                hasChanges = true;
                logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_DATA", targetEntityLog, `Data diubah. JM: '${oldJm}'->'${jmToSave}', JP: '${oldJp}'->'${jpToSave}', Ket: '${oldKet}'->'${ketLiburToSave}'`, "SUCCESS");
            }
        } else if (jmToSave || jpToSave || ketLiburToSave) {
            // Jika data baru, tambahkan ke array untuk 'append' nanti
            const dateParts = tanggal.split("/");
            if (dateParts.length === 3) {
                const dateObject = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
                let newRow = new Array(headers.length).fill('');
                newRow[namaColIdx] = nama;
                newRow[tanggalColIdx] = dateObject;
                newRow[masukColIdx] = jmToSave;
                newRow[pulangColIdx] = jpToSave;
                newRow[ketLiburManualColIdx] = ketLiburToSave;
                rowsToAppend.push(newRow); // Kumpulkan baris baru
                logUserActivity(actorUsername, actorRole, "CREATE_CEKLOK_DATA", targetEntityLog, `Data dibuat. JM: '${jmToSave}', JP: '${jpToSave}', Ket: '${ketLiburToSave}'`, "SUCCESS");
            }
        }
    });

    // 5. Tulis kembali semua perubahan ke sheet dalam satu kali operasi
    if (hasChanges) {
        dataRange.setValues(allSheetData);
    }

    // 6. Tambahkan semua baris baru dalam satu kali operasi
    if (rowsToAppend.length > 0) {
        sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, headers.length).setValues(rowsToAppend);
    }
    
    // (Opsional) Format ulang kolom jika ada baris baru yang ditambahkan
    if (rowsToAppend.length > 0) {
        if (masukColIdx > -1) sheet.getRange(2, masukColIdx + 1, sheet.getLastRow() - 1, 1).setNumberFormat("@");
        if (pulangColIdx > -1) sheet.getRange(2, pulangColIdx + 1, sheet.getLastRow() - 1, 1).setNumberFormat("@");
        if (ketLiburManualColIdx > -1) sheet.getRange(2, ketLiburManualColIdx + 1, sheet.getLastRow() - 1, 1).setNumberFormat("@");
    }

    const detailLogUmum = `Penyimpanan batch untuk periode: ${bulanTahunSimpan}, Jumlah item input: ${dataInput.length}. Perubahan: ${hasChanges}, Baris Baru: ${rowsToAppend.length}`;
    logUserActivity(actorUsername, actorRole, "CEKLOK_BATCH_SAVE_COMPLETE", nama, detailLogUmum, "SUCCESS");
    return "Data berhasil disimpan.";

  } catch (e) {
    Logger.log(`Error in simpanData (Batch Version) (Nama: ${nama}): ${e.toString()}\nStack: ${e.stack}`);
    logUserActivity(actorUsername, actorRole, "UPDATE_CEKLOK_SYSTEM_ERROR", nama || "N/A", `Error sistem: ${e.message}`, "ERROR");
    return `Error saat menyimpan: ${e.message}`;
  }
}

// ... (sisa kode di code.gs.html tetap sama)

/**
 * Menyiapkan data rekapitulasi kehadiran untuk dicetak ke sheet CETAK (template)
 * sesuai dengan tata letak yang dirinci, termasuk label statis per guru.
 * @param {string} selectedMonthYear Periode bulan dan tahun (format "MM/YYYY").
 * @return {object} Objek yang menandakan sukses atau gagal beserta pesan.
 */
function prepareMonthlyRekapForPrint(selectedMonthYear) {
  try {
    // 1. Validasi input dan persiapan periode (kode tetap sama seperti sebelumnya)
    if (!selectedMonthYear || !/^\d{2}\/\d{4}$/.test(selectedMonthYear)) {
      return { success: false, error: "Format Bulan/Tahun untuk cetak tidak valid (MM/YYYY)." };
    }
    const settings = getCeklokInputSettings();
    if (settings.success) {
      const parseMY = (myStr) => { 
        if (!myStr || !myStr.includes('/')) return null;
        const [m, y] = myStr.split('/'); 
        if (isNaN(parseInt(m)) || isNaN(parseInt(y))) return null;
        return new Date(parseInt(y), parseInt(m) - 1, 1); 
      };
      const reqDate = parseMY(selectedMonthYear);
      const minDate = parseMY(settings.adminDefinedMinMonthYear);
      const maxDate = parseMY(settings.serverCurrentMonthYear);
      if (reqDate && minDate && reqDate < minDate) {
        return { success: false, error: `Periode cetak ${selectedMonthYear} di luar rentang (${settings.adminDefinedMinMonthYear} - ${settings.serverCurrentMonthYear}).` };
      }
      if (reqDate && maxDate && reqDate > maxDate) {
         return { success: false, error: `Periode cetak ${selectedMonthYear} di luar rentang (${settings.adminDefinedMinMonthYear} - ${settings.serverCurrentMonthYear}).` };
      }
    } else {
      Logger.log(`Peringatan di prepareMonthlyRekapForPrint: Gagal mengambil settings - ${settings.error}`);
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const cetakSheet = ss.getSheetByName(CETAK_SHEET_NAME);

    if (!namaGuruSheet) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (!ceklokManualSheet) return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };
    if (!cetakSheet) return { success: false, error: `Sheet '${CETAK_SHEET_NAME}' (template) tidak ditemukan.` };

    // 2. Ambil daftar guru
    const daftarNamaGuru = namaGuruSheet.getLastRow() > 0 ?
                           namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1)
                                      .getValues().flat().filter(String).map(g => String(g).trim()) :
                           [];
    if (daftarNamaGuru.length === 0) {
      cetakSheet.getRange("C2").setValue("Tidak ada data guru.");
      return { success: true, message: "Tidak ada data nama guru di sheet 'Nama_Guru'. Template CETAK diinfokan." };
    }

    // 3. Persiapan periode dan tanggal (kode tetap sama)
    const [mmStr, yyyyStr] = selectedMonthYear.split('/');
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(yyyyStr, 10);
    
    const tanggalAwalObj = new Date(yyyy, mm - 1, 1);
    const tanggalAkhirObj = new Date(yyyy, mm, 0);
    const jumlahHari = tanggalAkhirObj.getDate();

    const tanggalAwalFormatted = Utilities.formatDate(tanggalAwalObj, Session.getScriptTimeZone(), "yyyy-MM-dd");
    const tanggalAkhirFormatted = Utilities.formatDate(tanggalAkhirObj, Session.getScriptTimeZone(), "yyyy-MM-dd");

    // 4. Mengisi informasi global di template "CETAK" (kode tetap sama)
    cetakSheet.getRange("C2").setValue(`${tanggalAwalFormatted} ~ ${tanggalAkhirFormatted}`);
    cetakSheet.getRange("L2").setValue(tanggalAkhirFormatted);

    const nomorTanggalHeader = [];
    for (let i = 1; i <= jumlahHari; i++) {
      nomorTanggalHeader.push(i);
    }
    for (let i = jumlahHari + 1; i <= 31; i++) {
        nomorTanggalHeader.push("");
    }
    cetakSheet.getRange("A3:AE3").clearContent(); 
    cetakSheet.getRange(3, 1, 1, nomorTanggalHeader.length).setValues([nomorTanggalHeader])
              .setHorizontalAlignment("center");

    // 5. Ambil data ceklok manual (kode tetap sama)
    const ceklokManualData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = ceklokManualData[0].map(h => String(h).trim());
    const idxNama = ceklokHeaders.indexOf("Nama_Guru");
    const idxTanggal = ceklokHeaders.indexOf("Tanggal");
    const idxMasuk = ceklokHeaders.indexOf("Jam_Masuk");
    const idxPulang = ceklokHeaders.indexOf("Jam_Pulang");
    const idxKetManual = ceklokHeaders.indexOf("Ket_Libur_Manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap/tidak sesuai." };
    }

    // 6. Membersihkan area data guru lama di sheet "CETAK" (kode tetap sama)
    const BARIS_MULAI_DATA_GURU_DI_TEMPLATE = 4;
    const estimasiBarisAkhirDataLama = BARIS_MULAI_DATA_GURU_DI_TEMPLATE + (daftarNamaGuru.length * 3) + 5; // +5 buffer
    const rangeDataLamaUntukDibersihkan = cetakSheet.getRange(
        BARIS_MULAI_DATA_GURU_DI_TEMPLATE, 1,
        Math.max(1, estimasiBarisAkhirDataLama - BARIS_MULAI_DATA_GURU_DI_TEMPLATE + 1), 
        cetakSheet.getMaxColumns()
    );
    rangeDataLamaUntukDibersihkan.clearContent();
    Logger.log(`Area data guru lama di sheet CETAK (mulai baris ${BARIS_MULAI_DATA_GURU_DI_TEMPLATE}) telah dibersihkan.`);

    // 7. Iterasi melalui daftar guru dan mengisi data
    let barisSaatIni = BARIS_MULAI_DATA_GURU_DI_TEMPLATE;

    daftarNamaGuru.forEach((namaGuru, index) => {
      // --- BARIS PERTAMA BLOK GURU (No, Nama, Label Statis) ---
      // Kolom A (indeks 1): "ID:"
      cetakSheet.getRange(barisSaatIni, 1).setValue("ID:").setHorizontalAlignment("left"); 
      // Kolom C (indeks 3): Nomor Urut
      cetakSheet.getRange(barisSaatIni, 3).setValue(index + 1).setHorizontalAlignment("center");
      // Kolom I (indeks 9): "Nama:"
      cetakSheet.getRange(barisSaatIni, 9).setValue("Nama:").setHorizontalAlignment("left");
      // Kolom K (indeks 11): Nama Guru
      cetakSheet.getRange(barisSaatIni, 11).setValue(namaGuru).setHorizontalAlignment("left");
      // Kolom S (indeks 19): "Dept.:"
      cetakSheet.getRange(barisSaatIni, 19).setValue("Dept.:").setHorizontalAlignment("left");
      // Kolom U (indeks 21): "MTS~TANUNTUNG"
      cetakSheet.getRange(barisSaatIni, 21).setValue("MTS~TANUNTUNG").setHorizontalAlignment("left");


      // --- BARIS KEDUA BLOK GURU (Jam Masuk) ---
      const barisJamMasuk = barisSaatIni + 1;
      const arrayJamMasuk = [];

      // --- BARIS KETIGA BLOK GURU (Jam Pulang) ---
      const barisJamPulang = barisSaatIni + 2;
      const arrayJamPulang = [];

      for (let tgl = 1; tgl <= jumlahHari; tgl++) {
        const tanggalCeklokStr = Utilities.formatDate(new Date(yyyy, mm - 1, tgl), Session.getScriptTimeZone(), "dd/MM/yyyy");
        
        let jamMasukUntukHariIni = ""; 
        let jamPulangUntukHariIni = "";
        
        const dataCeklokHariIni = ceklokManualData.find(row =>
          String(row[idxNama]).trim() === namaGuru &&
          row[idxTanggal] instanceof Date &&
          Utilities.formatDate(new Date(row[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === tanggalCeklokStr
        );

        if (dataCeklokHariIni) {
          const ketManual = String(dataCeklokHariIni[idxKetManual] || "").trim();
          if (ketManual === "") { 
            const jamMasukDb = String(dataCeklokHariIni[idxMasuk] || "").trim();
            const jamPulangDb = String(dataCeklokHariIni[idxPulang] || "").trim();

            jamMasukUntukHariIni = formatTimeToHHMM_or_Empty(jamMasukDb);
            jamPulangUntukHariIni = formatTimeToHHMM_or_Empty(jamPulangDb);
          }
        }
        arrayJamMasuk.push(jamMasukUntukHariIni);
        arrayJamPulang.push(jamPulangUntukHariIni);
      }
      
      for (let i = jumlahHari; i < 31; i++) { // Pastikan panjang array 31 untuk A-AE
          arrayJamMasuk.push("");
          arrayJamPulang.push("");
      }

      // Tulis baris jam masuk (mulai dari kolom A/1 sampai AE/31)
      if (arrayJamMasuk.length > 0) {
        cetakSheet.getRange(barisJamMasuk, 1, 1, arrayJamMasuk.length).setValues([arrayJamMasuk])
                  .setHorizontalAlignment("center").setNumberFormat("@");
      }
      // Tulis baris jam pulang
      if (arrayJamPulang.length > 0) {
        cetakSheet.getRange(barisJamPulang, 1, 1, arrayJamPulang.length).setValues([arrayJamPulang])
                  .setHorizontalAlignment("center").setNumberFormat("@");
      }
      
      barisSaatIni += 3; // Pindah ke blok 3 baris berikutnya untuk guru selanjutnya
    });

    SpreadsheetApp.flush(); 
    return { success: true, message: `Sheet '${CETAK_SHEET_NAME}' berhasil disiapkan untuk periode ${selectedMonthYear}.` };

  } catch (e) {
    Logger.log(`Error di prepareMonthlyRekapForPrint untuk periode ${selectedMonthYear}: ${e.toString()}\nStack: ${e.stack}`);
    return { success: false, error: `Gagal menyiapkan data cetak: ${e.message}` };
  }
}

function downloadPDF() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(CETAK_SHEET_NAME);
    if (!sheet) return { error: `Sheet '${CETAK_SHEET_NAME}' tidak ditemukan.` };

    const exportUrl = ss.getUrl().replace(/edit$/, '') + 'export?';
    const params = {
      format: 'pdf', portrait: false, fitw: true,
      top_margin: 0.4, bottom_margin: 0.4, left_margin: 0.4, right_margin: 0.4,
      sheetnames: false, printtitle: false, pagenumbers: false,
      gridlines: false, fzr: false, gid: sheet.getSheetId()
    };
    const query = Object.entries(params).map(([k, v]) => `${k}=${v}`).join('&');
    const blob = UrlFetchApp.fetch(exportUrl + query, {
      headers: { Authorization: 'Bearer ' + ScriptApp.getOAuthToken() }
    }).getBlob().setName(`Ceklok_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd_HH-mm")}.pdf`);

    const folderName = 'Ceklok_PDF_MTSTANUNTUNG_Generated';
    let folder = DriveApp.getFoldersByName(folderName);
    folder = folder.hasNext() ? folder.next() : DriveApp.createFolder(folderName);

    const files = folder.getFilesByName(blob.getName());
    while(files.hasNext()) files.next().setTrashed(true);

    const file = folder.createFile(blob);
    return file.getUrl();
  } catch (e) {
    Logger.log(`Error downloadPDF: ${e.toString()}`);
    return { error: `Gagal membuat PDF: ${e.message}` };
  }
}

function getCeklokHasil() { // Fungsi ini mungkin perlu parameter bulan jika hasil cekloknya dinamis per bulan
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(HASIL_CEKLOK_SHEET_NAME);
    if (!sheet) return { error: `Sheet '${HASIL_CEKLOK_SHEET_NAME}' tidak ditemukan.` };
    if (sheet.getLastRow() < 2) return { headers: ["Info"], data: [["Data di Hasil Ceklok kosong."]] };

    const NUM_COLUMNS_TO_READ = 32; // AF
    const colsToFetch = Math.min(NUM_COLUMNS_TO_READ, sheet.getMaxColumns());
    if (colsToFetch === 0) return { headers: ["Info"], data: [["Sheet Hasil Ceklok tidak punya kolom."]] };

    const headers = sheet.getRange(2, 1, 1, colsToFetch).getDisplayValues()[0];
    let dataRows = [];
    if (sheet.getLastRow() > 2) {
      dataRows = sheet.getRange(3, 1, sheet.getLastRow() - 2, colsToFetch).getDisplayValues();
    }
    return { headers: headers, data: dataRows };
  } catch (e) {
    Logger.log(`Error in getCeklokHasil: ${e.toString()}`);
    return { error: `Gagal mengambil hasil ceklok: ${e.message}` };
  }
}

function getKalenderPendidikanEntries() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    if (!sheet) {
        sheet = ensureSheet(KALENDER_SHEET_NAME, ["Tanggal (dd/mm/yyyy)", "Keterangan"]);
        Logger.log(`Sheet '${KALENDER_SHEET_NAME}' dibuat saat getKalenderPendidikanEntries.`);
        return []; // Kembalikan array kosong karena baru dibuat
    }
    if (sheet.getLastRow() < 2) return [];

    const values = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getDisplayValues();
    return values.map((row, index) => ({
      date: row[0], description: row[1], sheetRow: index + 2
    })).filter(entry => entry.date && entry.date.trim() !== "");
  } catch (e) {
    Logger.log(`Error di getKalenderPendidikanEntries: ${e.toString()}`);
    return { error: `Gagal mengambil entri kalender: ${e.message}` };
  }
}

function addKalenderPendidikanEntry(entryData, actingUserUsername, actingUserRole) { // Tambahkan parameter
  try {
    if (!entryData || !entryData.date || !entryData.description) {
      logUserActivity(actingUserUsername, actingUserRole, "ADD_CALENDAR_ENTRY_FAIL", entryData.date || "N/A", "Data tidak lengkap (tanggal/deskripsi)", "FAIL");
      return {success: false, error: "Data tidak lengkap. Tanggal dan Keterangan wajib."};
    }
    if (!/^\d{2}\/\d{2}\/\d{4}$/.test(entryData.date)) {
      logUserActivity(actingUserUsername, actingUserRole, "ADD_CALENDAR_ENTRY_FAIL", entryData.date, "Format Tanggal salah (seharusnya dd/MM/yyyy)", "FAIL");
      return {success: false, error: "Format Tanggal salah (dd/mm/yyyy)."};
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    if (!sheet) {
      logUserActivity(actingUserUsername, actingUserRole, "ADD_CALENDAR_ENTRY_ERROR", entryData.date, `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan`, "ERROR");
      return {success: false, error: `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan.`};
    }

    sheet.appendRow([entryData.date, entryData.description]);
    logUserActivity(actingUserUsername, actingUserRole, "ADD_CALENDAR_ENTRY_SUCCESS", entryData.date, `Keterangan: ${entryData.description}`, "SUCCESS");
    return {success: true, message: "Entri Kalender berhasil ditambahkan."};
  } catch (e) {
    Logger.log(`Error di addKalenderPendidikanEntry: ${e.toString()}`);
    logUserActivity(actingUserUsername, actingUserRole, "ADD_CALENDAR_ENTRY_ERROR", entryData.date || "N/A", e.message, "ERROR");
    return {success: false, error: `Gagal menambah entri kalender: ${e.message}`};
  }
}

function deleteKalenderPendidikanEntry(sheetRow, actingUserUsername, actingUserRole) {
  let entryDateForLog = `Baris: ${sheetRow}`; // Fallback jika detail tidak bisa diambil
  let entryDescForLog = "";
  try {
    if (!sheetRow || typeof sheetRow !== 'number' || sheetRow < 2) {
      logUserActivity(actingUserUsername, actingUserRole, "DELETE_CALENDAR_ENTRY_FAIL", `Baris: ${sheetRow}`, "Nomor baris tidak valid", "FAIL");
      return {success: false, error: "Nomor baris tidak valid."};
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    if (!sheet) {
      logUserActivity(actingUserUsername, actingUserRole, "DELETE_CALENDAR_ENTRY_ERROR", `Baris: ${sheetRow}`, `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan`, "ERROR");
      return {success: false, error: `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan.`};
    }
    if (sheetRow > sheet.getLastRow()) {
      logUserActivity(actingUserUsername, actingUserRole, "DELETE_CALENDAR_ENTRY_FAIL", `Baris: ${sheetRow}`, "Baris sudah dihapus atau tidak ada", "FAIL");
      return {success: false, error: "Baris sudah dihapus atau tidak ada."};
    }

    // Ambil detail entri sebelum dihapus untuk logging yang lebih baik
    try {
        const entryDetails = sheet.getRange(sheetRow, 1, 1, 2).getDisplayValues()[0];
        entryDateForLog = entryDetails[0] || `Baris: ${sheetRow}`;
        entryDescForLog = entryDetails[1] || "";
    } catch (detailError) {
        Logger.log(`Gagal mengambil detail entri kalender untuk log: ${detailError.toString()}`);
    }

    sheet.deleteRow(sheetRow);
    logUserActivity(actingUserUsername, actingUserRole, "DELETE_CALENDAR_ENTRY_SUCCESS", entryDateForLog, `Keterangan: ${entryDescForLog}`, "SUCCESS");
    return {success: true, message: "Entri Kalender berhasil dihapus."};
  } catch (e) {
    Logger.log(`Error di deleteKalenderPendidikanEntry: ${e.toString()}`);
    logUserActivity(actingUserUsername, actingUserRole, "DELETE_CALENDAR_ENTRY_ERROR", entryDateForLog, `Error: ${e.message}, Detail Asli: ${entryDescForLog}`, "ERROR");
    return {success: false, error: `Gagal menghapus entri kalender: ${e.message}`};
  }
}

function getUsersForAdmin() { // Tidak ada perubahan signifikan di sini, UI client akan handle pembatasan tampilan
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    if (usersSheet.getLastRow() < 2) return { success: true, users: [] };
    const data = usersSheet.getRange(2, 1, usersSheet.getLastRow() - 1, Math.min(4, usersSheet.getLastColumn())).getValues();
    const users = data.map(row => ({
      username: String(row[0]).trim(),
      role: String(row[2]).trim(),
      teacherName: (row.length > 3 && row[3]) ? String(row[3]).trim() : ""
    })).filter(user => user.username);
    return { success: true, users: users };
  } catch (e) {
    Logger.log(`Error in getUsersForAdmin: ${e.toString()}`);
    return { success: false, error: `Gagal mengambil pengguna: ${e.message}` };
  }
}

// Modifikasi addNewUser
function addNewUser(userData, actingUserUsername, actingUserRole) { // Tambahkan actingUserUsername
  try {
    if (!userData.username || !userData.password || !userData.role) {
      logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username || "N/A", "Data tidak lengkap (username/password/role)", "FAIL");
      return { success: false, error: "Username, password, dan role harus diisi." };
    }
    // Tambahan: Validasi peran yang ditambahkan oleh admin
    if (actingUserRole === ROLE_ADMIN && userData.role === ROLE_SUPERADMIN) {
      logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username, "Admin mencoba membuat Superadmin", "FAIL");
      return { success: false, error: "Admin tidak dapat menambahkan pengguna dengan peran Superadmin." };
    }
    if (userData.role !== ROLE_USER && userData.role !== ROLE_ADMIN && userData.role !== ROLE_SUPERADMIN) {
        logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username, `Peran tidak valid: ${userData.role}`, "FAIL");
        return { success: false, error: `Peran '${userData.role}' tidak valid.`};
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
        logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_ERROR", userData.username, `Sheet '${USERS_SHEET_NAME}' tidak ditemukan`, "ERROR");
        return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    if (usersSheet.getLastRow() === 0) {
      usersSheet.appendRow(["Username", "Password", "Role", "Nama_Guru_Asli", "GoogleEmail", "PrimaryEmail"]); // Pastikan PrimaryEmail ada jika belum
      usersSheet.getRange("A1:F1").setFontWeight("bold");
    }

    const usernames = usersSheet.getRange(2, 1, usersSheet.getLastRow() > 1 ? usersSheet.getLastRow() - 1 : 1, 1)
                                .getValues().flat().map(u => String(u).trim());
    if (usernames.includes(userData.username.trim())) {
      logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username.trim(), "Username sudah ada", "FAIL");
      return { success: false, error: `Username '${userData.username}' sudah ada.` };
    }

    let teacherNameToSave = "";
    if (userData.role === ROLE_USER) {
      if (!userData.teacherName) {
        logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username, "Nama Guru Asli wajib untuk role user", "FAIL");
        return { success: false, error: "Nama Guru Asli wajib untuk role 'user'." };
      }
      const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
      if (namaGuruSheet) {
        const guruList = namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
        if (!guruList.includes(userData.teacherName.trim())) {
             logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_FAIL", userData.username, `Nama Guru '${userData.teacherName}' tidak ada di daftar`, "FAIL");
             return { success: false, error: `Nama Guru '${userData.teacherName}' tidak ada di daftar. Tambahkan dulu.` };
        }
        teacherNameToSave = userData.teacherName.trim();
      } else {
        logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_ERROR", userData.username, `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan`, "ERROR");
        return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
      }
    }
    // Kolom GoogleEmail dan PrimaryEmail akan default kosong saat user baru dibuat via form ini
    usersSheet.appendRow([userData.username.trim(), userData.password, userData.role.trim(), teacherNameToSave, "", ""]);
    logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_SUCCESS", userData.username.trim(), `Role: ${userData.role.trim()}, NamaGuru: ${teacherNameToSave || 'N/A'}`, "SUCCESS");
    return { success: true, message: "Pengguna baru berhasil ditambahkan." };
  } catch (e) {
    Logger.log(`Error in addNewUser: ${e.toString()}`);
    logUserActivity(actingUserUsername, actingUserRole, "CREATE_USER_ERROR", userData.username || "N/A", e.message, "ERROR");
    return { success: false, error: `Gagal menambah pengguna: ${e.message}` };
  }
}

// Modifikasi updateUserByUsername
function updateUserByUsername(usernameToUpdate, userDataToUpdate, actingUserUsername, actingUserRole) { // Tambahkan actingUserUsername
  try {
    if (!usernameToUpdate || !userDataToUpdate || !userDataToUpdate.newRole) {
      logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Data tidak lengkap (username/newRole)", "FAIL");
      return { success: false, error: "Username dan role baru wajib." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_ERROR", usernameToUpdate, `Sheet '${USERS_SHEET_NAME}' tidak ditemukan`, "ERROR");
        return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    const data = usersSheet.getDataRange().getValues();
    let targetUserRowIndex = -1;
    let currentTargetRole = "";
    let oldPassword = ""; // Untuk mencatat jika password diubah
    let oldTeacherName = ""; // Untuk mencatat jika nama guru diubah

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === usernameToUpdate) {
        targetUserRowIndex = i + 1;
        oldPassword = String(data[i][1]); // Password ada di kolom B (indeks 1)
        currentTargetRole = String(data[i][2]).trim(); // Role ada di kolom C (indeks 2)
        oldTeacherName = String(data[i][3] || "").trim(); // Nama_Guru_Asli di kolom D (indeks 3)
        break;
      }
    }
    if (targetUserRowIndex === -1) {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Pengguna target tidak ditemukan", "FAIL");
        return { success: false, error: `Pengguna '${usernameToUpdate}' tidak ditemukan.` };
    }

    // --- Logika Otorisasi ---
    if (actingUserRole === ROLE_ADMIN) {
      if (currentTargetRole === ROLE_SUPERADMIN) {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Admin mencoba memodifikasi Superadmin", "FAIL");
        return { success: false, error: "Admin tidak dapat memodifikasi akun Superadmin." };
      }
      if (userDataToUpdate.newRole === ROLE_SUPERADMIN) {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Admin mencoba mempromosikan ke Superadmin", "FAIL");
        return { success: false, error: "Admin tidak dapat mempromosikan pengguna menjadi Superadmin." };
      }
    }

    if (actingUserRole === ROLE_SUPERADMIN || actingUserRole === ROLE_ADMIN) { // Superadmin bisa mengubah siapa saja, admin dengan batasan
        // Cek jika superadmin mencoba mengubah peran superadmin terakhir
        if (currentTargetRole === ROLE_SUPERADMIN && userDataToUpdate.newRole !== ROLE_SUPERADMIN) {
            let superadminCount = 0;
            for (let i = 1; i < data.length; i++) {
                if (String(data[i][2]).trim() === ROLE_SUPERADMIN) superadminCount++;
            }
            if (superadminCount <= 1) {
                logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Mencoba mengubah peran Superadmin terakhir", "FAIL");
                return { success: false, error: "Tidak dapat mengubah peran Superadmin terakhir." };
            }
        }
    } else { // Jika bukan admin atau superadmin (misal, user biasa mencoba akses fungsi ini)
        return { success: false, error: "Anda tidak memiliki hak untuk mengubah data pengguna." };
    }
    // --- Akhir Logika Otorisasi ---

    let changesMadeDetails = [];

    // Update Role jika berubah
    if (currentTargetRole !== userDataToUpdate.newRole.trim()) {
        usersSheet.getRange(targetUserRowIndex, 3).setValue(userDataToUpdate.newRole.trim());
        changesMadeDetails.push(`Role: ${currentTargetRole} -> ${userDataToUpdate.newRole.trim()}`);
    }

    // Update Password jika ada password baru
    if (userDataToUpdate.newPassword) {
      usersSheet.getRange(targetUserRowIndex, 2).setValue(userDataToUpdate.newPassword);
      changesMadeDetails.push("Password diubah");
    }

    let teacherNameToSave = oldTeacherName;
    if (userDataToUpdate.newRole === ROLE_USER) {
      if (!userDataToUpdate.newTeacherName) {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, "Nama Guru Asli baru wajib untuk role 'user'", "FAIL");
        return { success: false, error: "Nama Guru Asli baru wajib untuk role 'user'." };
      }
      const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
      if (namaGuruSheet) {
        const guruList = namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
        if (!guruList.includes(userDataToUpdate.newTeacherName.trim())) {
             logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_FAIL", usernameToUpdate, `Nama Guru baru '${userDataToUpdate.newTeacherName}' tidak valid`, "FAIL");
             return { success: false, error: `Nama Guru '${userDataToUpdate.newTeacherName}' tidak ada di daftar.` };
        }
        teacherNameToSave = userDataToUpdate.newTeacherName.trim();
      } else {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_ERROR", usernameToUpdate, `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan`, "ERROR");
        return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
      }
    } else { // Jika peran baru bukan user, nama guru dikosongkan
        teacherNameToSave = "";
    }

    if (oldTeacherName !== teacherNameToSave) {
        usersSheet.getRange(targetUserRowIndex, 4).setValue(teacherNameToSave);
        changesMadeDetails.push(`NamaGuru: ${oldTeacherName || 'N/A'} -> ${teacherNameToSave || 'N/A'}`);
    }


    if (changesMadeDetails.length > 0) {
        // === BARU: Log aktivitas pembaruan pengguna berhasil ===
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_SUCCESS", usernameToUpdate, changesMadeDetails.join("; "), "SUCCESS");
        // ======================================================
    } else {
        logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_INFO", usernameToUpdate, "Tidak ada perubahan data terdeteksi", "INFO");
    }
    return { success: true, message: `Pengguna '${usernameToUpdate}' berhasil diperbarui.` + (changesMadeDetails.length > 0 ? "" : " (Tidak ada perubahan data)") };
  } catch (e) {
    Logger.log(`Error in updateUserByUsername: ${e.toString()}`);
    // === BARU: Log error sistem saat update pengguna ===
    logUserActivity(actingUserUsername, actingUserRole, "UPDATE_USER_ERROR", usernameToUpdate, e.message, "ERROR");
    // =================================================
    return { success: false, error: `Gagal memperbarui pengguna: ${e.message}` };
  }
}

// Modifikasi deleteUserByUsername
function deleteUserByUsername(usernameToDelete, actingUserUsername, actingUserRole) { // Tambahkan actingUserUsername
  try {
    if (!usernameToDelete) {
        logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_FAIL", "N/A", "Username target tidak diberikan", "FAIL");
        return { success: false, error: "Username wajib." };
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
        logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_ERROR", usernameToDelete, `Sheet '${USERS_SHEET_NAME}' tidak ditemukan`, "ERROR");
        return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    const data = usersSheet.getDataRange().getValues();
    let targetUserRowIndex = -1;
    let roleToDelete = '';

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === usernameToDelete) {
        targetUserRowIndex = i + 1;
        roleToDelete = String(data[i][2]).trim(); // Kolom C adalah Role
        break;
      }
    }
    if (targetUserRowIndex === -1) {
        logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_FAIL", usernameToDelete, "Pengguna target tidak ditemukan", "FAIL");
        return { success: false, error: `Pengguna '${usernameToDelete}' tidak ditemukan.` };
    }

    // --- Logika Otorisasi dan Pencegahan ---
    if (actingUserRole === ROLE_ADMIN && roleToDelete === ROLE_SUPERADMIN) {
      logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_FAIL", usernameToDelete, "Admin mencoba menghapus Superadmin", "FAIL");
      return { success: false, error: `Admin tidak dapat menghapus akun Superadmin.` };
    }

    if (roleToDelete === ROLE_SUPERADMIN) {
      let superadminCount = 0;
      for (let i = 1; i < data.length; i++) {
        if (String(data[i][2]).trim() === ROLE_SUPERADMIN) superadminCount++;
      }
      if (superadminCount <= 1) {
        logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_FAIL", usernameToDelete, "Mencoba menghapus Superadmin terakhir", "FAIL");
        return { success: false, error: `Tidak dapat menghapus satu-satunya akun Superadmin.` };
      }
    }
    
    if (roleToDelete === ROLE_ADMIN && actingUserRole !== ROLE_SUPERADMIN) { // Jika admin mencoba menghapus admin lain
        let adminCount = 0;
        let superAdminExists = false;
        for (let i = 1; i < data.length; i++) {
            const userRole = String(data[i][2]).trim();
            if(userRole === ROLE_ADMIN) adminCount++;
            if(userRole === ROLE_SUPERADMIN) superAdminExists = true;
        }
        let currentAdminsAfterDelete = 0;
        for (let i=1; i < data.length; i++) {
            if (String(data[i][0]).trim() !== usernameToDelete && String(data[i][2]).trim() === ROLE_ADMIN) {
                currentAdminsAfterDelete++;
            }
        }
        if (currentAdminsAfterDelete < 1 && !superAdminExists) {
            logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_FAIL", usernameToDelete, "Mencoba menghapus Admin terakhir tanpa Superadmin pengganti", "FAIL");
            return { success: false, error: `Tidak dapat menghapus satu-satunya akun Admin jika tidak ada Superadmin.` };
        }
    }
    // Seorang superadmin dapat menghapus admin biasa meskipun itu admin terakhir, karena superadmin masih ada.
    // Seorang admin tidak bisa menghapus dirinya sendiri jika ia adalah satu-satunya admin dan tidak ada superadmin (perlu penanganan di client atau jika usernameToDelete === actingUsername)

    // --- Akhir Logika Otorisasi ---
    usersSheet.deleteRow(targetUserRowIndex);
    logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_SUCCESS", usernameToDelete, `Role dihapus: ${roleToDelete}`, "SUCCESS");
    return { success: true, message: `Pengguna '${usernameToDelete}' berhasil dihapus.` };
  } catch (e) {
    Logger.log(`Error in deleteUserByUsername: ${e.toString()}`);
    logUserActivity(actingUserUsername, actingUserRole, "DELETE_USER_ERROR", usernameToDelete, e.message, "ERROR");
    return { success: false, error: `Gagal menghapus pengguna: ${e.message}` };
  }
}

function getTeachersForAdmin() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    if (!sheetGuru) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (sheetGuru.getLastRow() === 0) return { success: true, teachers: [] };

    const guruList = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
    return { success: true, teachers: guruList };
  } catch (e) {
    Logger.log(`Error in getTeachersForAdmin: ${e.toString()}`);
    return { success: false, error: `Gagal mengambil data guru: ${e.message}` };
  }
}

function addNewTeacher(teacherName) {
  try {
    if (!teacherName || teacherName.trim() === "") return { success: false, error: "Nama guru tidak boleh kosong." };
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    if (!sheetGuru) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (sheetGuru.getLastRow() === 0) { // Jika sheet kosong, tambahkan header
        sheetGuru.appendRow(["Nama Guru"]);
        sheetGuru.getRange("A1").setFontWeight("bold");
    }


    const guruList = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
    if (guruList.includes(teacherName.trim())) {
      return { success: false, error: `Nama guru '${teacherName}' sudah ada.` };
    }
    sheetGuru.appendRow([teacherName.trim()]);
    return { success: true, message: `Nama guru '${teacherName.trim()}' berhasil ditambahkan.` };
  } catch (e) {
    Logger.log(`Error in addNewTeacher: ${e.toString()}`);
    return { success: false, error: `Gagal menambah nama guru: ${e.message}` };
  }
}

function updateTeacherByName(oldTeacherName, newTeacherName) {
  try {
    if (!oldTeacherName || !newTeacherName || oldTeacherName.trim() === "" || newTeacherName.trim() === "") {
      return { success: false, error: "Nama guru lama dan baru tidak boleh kosong." };
    }
    if (oldTeacherName.trim() === newTeacherName.trim()) return { success: false, error: "Nama baru sama dengan nama lama." };

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    if (!sheetGuru) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };

    const dataGuru = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues();
    let rowIndexGuru = -1;
    let guruListForValidation = [];
    for (let i = 0; i < dataGuru.length; i++) {
      const currentTeacher = String(dataGuru[i][0]).trim();
      guruListForValidation.push(currentTeacher);
      if (currentTeacher === oldTeacherName.trim()) rowIndexGuru = i + 1;
    }
    if (rowIndexGuru === -1) return { success: false, error: `Nama guru '${oldTeacherName}' tidak ditemukan.` };
    if (guruListForValidation.includes(newTeacherName.trim())) return { success: false, error: `Nama guru '${newTeacherName}' sudah ada.` };

    sheetGuru.getRange(rowIndexGuru, 1).setValue(newTeacherName.trim());

    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (usersSheet && usersSheet.getLastRow() > 1) {
      const dataUsers = usersSheet.getRange(2, 1, usersSheet.getLastRow() - 1, 4).getValues(); // Kolom D adalah index 3
      for (let i = 0; i < dataUsers.length; i++) {
        if (dataUsers[i][3] && String(dataUsers[i][3]).trim() === oldTeacherName.trim()) {
          usersSheet.getRange(i + 2, 4).setValue(newTeacherName.trim());
        }
      }
    }
    return { success: true, message: `Nama guru '${oldTeacherName}' diperbarui menjadi '${newTeacherName}'. Referensi di Users juga diupdate.` };
  } catch (e) {
    Logger.log(`Error in updateTeacherByName: ${e.toString()}`);
    return { success: false, error: `Gagal memperbarui nama guru: ${e.message}` };
  }
}

function deleteTeacherByName(teacherName) {
  try {
    if (!teacherName || teacherName.trim() === "") return { success: false, error: "Nama guru tidak boleh kosong." };
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    if (!sheetGuru) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };

    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (usersSheet && usersSheet.getLastRow() > 1) {
      const dataUsersTeacherNames = usersSheet.getRange(2, 4, usersSheet.getLastRow() - 1, 1).getValues().flat().map(name => name ? String(name).trim() : "");
      if (dataUsersTeacherNames.includes(teacherName.trim())) {
        return { success: false, error: `Guru '${teacherName}' terhubung ke user. Update/hapus user terkait dulu.` };
      }
    }

    const dataGuru = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues();
    let rowIndexGuru = -1;
    for (let i = 0; i < dataGuru.length; i++) {
      if (String(dataGuru[i][0]).trim() === teacherName.trim()) {
        rowIndexGuru = i + 1; break;
      }
    }
    if (rowIndexGuru === -1) return { success: false, error: `Nama guru '${teacherName}' tidak ditemukan.` };

    sheetGuru.deleteRow(rowIndexGuru);
    return { success: true, message: `Nama guru '${teacherName}' berhasil dihapus.` };
  } catch (e) {
    Logger.log(`Error in deleteTeacherByName: ${e.toString()}`);
    return { success: false, error: `Gagal menghapus nama guru: ${e.message}` };
  }
}

function getLoginHistory(actingUserRole, limit = 20) { // Tambahkan parameter actingUserRole
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const historySheet = ss.getSheetByName(LOGIN_HISTORY_SHEET_NAME);

        if (!historySheet) {
            return { success: true, history: [], message: `Sheet '${LOGIN_HISTORY_SHEET_NAME}' tidak ditemukan.` };
        }
        if (historySheet.getLastRow() <= 1) { // Hanya header atau kosong
            return { success: true, history: [] };
        }

        const lastRow = historySheet.getLastRow();
        const headerRows = 1;
        const dataRowsCount = lastRow - headerRows;

        // Jika admin yang meminta, kita mungkin perlu mengambil lebih banyak data awal
        // untuk di-filter, lalu ambil `limit` teratas.
        // Heuristik: ambil 5x lipat dari limit jika admin, untuk memberi ruang filter.
        const initialFetchCount = (actingUserRole === ROLE_ADMIN) ? Math.min(dataRowsCount, limit * 5) : Math.min(dataRowsCount, limit);

        if (initialFetchCount <= 0) {
            return { success: true, history: [] };
        }

        // Baca 3 kolom: Username, Timestamp, Nama_Guru
        const numColsToRead = Math.min(3, historySheet.getLastColumn());
        // Ambil dari baris terakhir ke atas sejumlah initialFetchCount
        const range = historySheet.getRange(lastRow - initialFetchCount + 1, 1, initialFetchCount, numColsToRead);
        const values = range.getDisplayValues();

        // Proses menjadi objek dan balik urutannya agar yang terbaru di awal
        let historyEntries = values.map(row => {
            return {
                username: row[0] || '-',
                timestamp: row[1] || '-',
                teacherName: (numColsToRead > 2 && row[2]) ? row[2] : '-'
                // Peran akan dicari jika diperlukan
            };
        }).reverse(); // Data terbaru sekarang ada di awal array

        if (actingUserRole === ROLE_ADMIN) {
            const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
            if (!usersSheet) {
                Logger.log("getLoginHistory: Sheet Users tidak ditemukan untuk lookup peran.");
                return { success: false, error: "Tidak dapat memfilter histori login: sheet pengguna tidak ditemukan."};
            }
            const usersData = usersSheet.getDataRange().getValues();
            const userHeaders = usersData[0].map(h => String(h).trim().toLowerCase());
            const usernameColIdx = userHeaders.indexOf("username");
            const roleColIdx = userHeaders.indexOf("role");

            if (usernameColIdx === -1 || roleColIdx === -1) {
                 Logger.log("getLoginHistory: Kolom Username/Role tidak ditemukan di sheet Users.");
                 return { success: false, error: "Tidak dapat memfilter histori login: konfigurasi sheet pengguna salah."};
            }

            // Buat map untuk lookup peran pengguna dengan cepat
            const userRolesMap = {};
            for (let i = 1; i < usersData.length; i++) {
                if(usersData[i][usernameColIdx]) {
                    userRolesMap[String(usersData[i][usernameColIdx]).trim()] = String(usersData[i][roleColIdx]).trim();
                }
            }

            const filteredHistory = [];
            for (const entry of historyEntries) {
                if (filteredHistory.length >= limit) { // Jika sudah mencapai batas 'limit' setelah filter
                    break;
                }
                const roleOfLoggedUser = userRolesMap[entry.username];
                // Hanya tambahkan jika peran pengguna yang login BUKAN superadmin
                if (roleOfLoggedUser !== ROLE_SUPERADMIN) {
                    filteredHistory.push(entry);
                }
            }
            historyEntries = filteredHistory; // Gunakan hasil filter
        } else { // Untuk superadmin atau peran lain (jika ada), ambil 'limit' teratas
            if (historyEntries.length > limit) {
                historyEntries = historyEntries.slice(0, limit);
            }
        }
        
        return { success: true, history: historyEntries };

    } catch (e) {
        Logger.log(`Error di getLoginHistory (Peran Aktor: ${actingUserRole}): ${e.toString()}`);
        return { success: false, error: `Gagal mengambil histori login: ${e.message}` };
    }
}

// Pastikan fungsi ini sudah ada di code.gs Anda
function ensureSheet(sheetName, headers = []) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    if (headers.length > 0) {
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setHorizontalAlignment("center");
      // Opsional: Sesuaikan lebar kolom untuk sheet log jika baru dibuat
      if (sheetName === ACTIVITY_LOG_SHEET_NAME && headers.length >= 7) {
        sheet.setColumnWidth(1, 170); // Timestamp
        sheet.setColumnWidth(2, 150); // ActorUsername
        sheet.setColumnWidth(3, 100); // ActorRole
        sheet.setColumnWidth(4, 180); // ActionType
        sheet.setColumnWidth(5, 150); // TargetEntity
        sheet.setColumnWidth(6, 250); // Details
        sheet.setColumnWidth(7, 100); // Status
      }
    }
  } else if (sheet.getLastRow() === 0 && headers.length > 0) { // Sheet ada tapi kosong
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setHorizontalAlignment("center");
      // (Anda bisa tambahkan penyesuaian kolom di sini juga jika sheet kosong)
  }
  return sheet;
}

function saveOrUpdateLockId(teacherName, lockId) {
  if (!teacherName || !lockId) {
    return { success: false, error: "Nama Guru dan LOCK_ID tidak boleh kosong." };
  }
  try {
    const lockIdSheet = ensureSheet(LOCK_ID_SHEET_NAME, ["Nama_Guru", "LOCK_ID"]);
    const data = lockIdSheet.getDataRange().getValues();
    let rowIndex = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === teacherName) {
        rowIndex = i + 1;
        break;
      }
    }
    if (rowIndex !== -1) {
      lockIdSheet.getRange(rowIndex, 2).setValue(lockId);
    } else {
      lockIdSheet.appendRow([teacherName, lockId]);
    }
    return { success: true, message: "LOCK_ID berhasil disimpan." };
  } catch (e) {
    Logger.log(`Error in saveOrUpdateLockId: ${e.toString()}`);
    return { success: false, error: `Gagal menyimpan LOCK_ID: ${e.message}` };
  }
}

function getLockIdForTeacher(teacherName) {
  if (!teacherName) return null;
  try {
    const lockIdSheet = ensureSheet(LOCK_ID_SHEET_NAME, ["Nama_Guru", "LOCK_ID"]);
    const data = lockIdSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === teacherName) {
        return data[i][1] ? String(data[i][1]).trim() : null;
      }
    }
    return null;
  } catch (e) {
    Logger.log(`Error in getLockIdForTeacher: ${e.toString()}`);
    return null;
  }
}

function formatTimeToHHMM_Excel(timeStr) {
  if (!timeStr || typeof timeStr !== 'string' || String(timeStr).trim() === "") {
    return "";
  }
  const parts = String(timeStr).trim().split(/[.:]/);
  if (parts.length === 2) {
    const h = String(parts[0]).padStart(2, '0');
    const m = String(parts[1]).padStart(2, '0');
    if (!isNaN(parseInt(h, 10)) && !isNaN(parseInt(m, 10)) &&
        parseInt(h, 10) >= 0 && parseInt(h, 10) < 24 &&
        parseInt(m, 10) >= 0 && parseInt(m, 10) < 60) {
      return `'${h}:${m}`;
    }
  }
  return "";
}

// Fungsi requestExcelExport yang LAMA tidak lagi digunakan secara langsung,
// digantikan oleh saveLockIdAndPrepareBackupSheet dan exportBackupSheetToExcel
// function requestExcelExport(teacherName, bulanTahun, lockIdFromUser) { ... }


function ensureTemplateSheetExists() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let templateSheet = ss.getSheetByName(TEMPLATE_SHEET_FOR_BACKUP); // TEMPLATE_SHEET_FOR_BACKUP = "Worksheet"
  if (!templateSheet) {
    templateSheet = ss.insertSheet(TEMPLATE_SHEET_FOR_BACKUP);
    const worksheetHeaders = [
      "LOCK ID", "TANGGAL", "HARI",
      "JAM MASUK", "JAM PULANG",
      "ALASAN TIDAK HADIR", "DESKRIPSI"
    ];
    templateSheet.appendRow(worksheetHeaders);
    templateSheet.getRange(1, 1, 1, worksheetHeaders.length).setFontWeight("bold").setHorizontalAlignment("center");
    SpreadsheetApp.flush();
    Logger.log(`Template sheet '${TEMPLATE_SHEET_FOR_BACKUP}' dibuat dengan header.`);
  } else if (templateSheet.getLastRow() === 0) { // Jika template ada tapi kosong
    const worksheetHeaders = [
      "LOCK ID", "TANGGAL", "HARI",
      "JAM MASUK", "JAM PULANG",
      "ALASAN TIDAK HADIR", "DESKRIPSI"
    ];
    templateSheet.appendRow(worksheetHeaders);
    templateSheet.getRange(1, 1, 1, worksheetHeaders.length).setFontWeight("bold").setHorizontalAlignment("center");
    SpreadsheetApp.flush();
    Logger.log(`Header ditambahkan ke template sheet '${TEMPLATE_SHEET_FOR_BACKUP}' yang kosong.`);
  }
  return templateSheet;
}

function saveLockIdAndPrepareBackupSheet(teacherName, bulanTahun, lockId, clientCeklokData) {
  try {
    SpreadsheetApp.flush();
    const saveLockResult = saveOrUpdateLockId(teacherName, lockId);
    if (!saveLockResult.success) {
      return { success: false, error: `Gagal menyimpan LOCK_ID: ${saveLockResult.error}` };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheetName = `${BACKUP_SHEET_PREFIX}${teacherName}`; // e.g. Worksheet_NamaGuru

    let existingBackupSheet = ss.getSheetByName(backupSheetName);
    if (existingBackupSheet) {
      ss.deleteSheet(existingBackupSheet);
      Logger.log(`Sheet cadangan lama '${backupSheetName}' dihapus.`);
    }
    SpreadsheetApp.flush();

    const templateSheet = ensureTemplateSheetExists();
    if (!templateSheet) {
        return { success: false, error: `Sheet template '${TEMPLATE_SHEET_FOR_BACKUP}' tidak ditemukan dan tidak dapat dibuat.` };
    }
    const newBackupSheet = templateSheet.copyTo(ss).setName(backupSheetName);
    newBackupSheet.clearContents(); // Hapus semua konten dari duplikat template
    
    const worksheetHeaders = [ // Definisikan header lagi untuk memastikan
      "LOCK ID", "TANGGAL", "HARI",
      "JAM MASUK", "JAM PULANG",
      "ALASAN TIDAK HADIR", "DESKRIPSI"
    ];
    newBackupSheet.appendRow(worksheetHeaders);
    newBackupSheet.getRange(1, 1, 1, worksheetHeaders.length).setFontWeight("bold").setHorizontalAlignment("center");
    SpreadsheetApp.flush();
    Logger.log(`Sheet cadangan baru '${backupSheetName}' dibuat dari template dan header ditambahkan.`);

    const dataToLoad = [];
    const scriptTimeZone = Session.getScriptTimeZone();
    let exportIdCounter = parseInt(lockId, 10);

    if (isNaN(exportIdCounter)) {
        Logger.log(`LOCK_ID "${lockId}" tidak valid untuk counter EXPORT_ID, menggunakan 1 sebagai basis.`);
        exportIdCounter = 1;
    }

    clientCeklokData.forEach((row, index) => {
      let formattedDateYYYYMMDD = "";
      if (row.tanggal && typeof row.tanggal === 'string' && row.tanggal.includes('/')) {
        const dateParts = row.tanggal.split("/");
        if (dateParts.length === 3) {
          const day = parseInt(dateParts[0], 10);
          const month = parseInt(dateParts[1], 10) - 1;
          const year = parseInt(dateParts[2], 10);
          if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
            const dateObject = new Date(year, month, day);
            formattedDateYYYYMMDD = Utilities.formatDate(dateObject, scriptTimeZone, "yyyy-MM-dd");
          }
        }
      }

      const jamMasukFormatted = formatTimeToHHMM_Excel(row.jamMasuk);
      const jamPulangFormatted = formatTimeToHHMM_Excel(row.jamPulang);
      const keteranganManual = row.keteranganLiburManual || "";

      dataToLoad.push([
        exportIdCounter + index,
        formattedDateYYYYMMDD,
        row.hari,
        jamMasukFormatted,
        jamPulangFormatted,
        keteranganManual,
        keteranganManual
      ]);
    });

    if (dataToLoad.length > 0) {
      newBackupSheet.getRange(2, 1, dataToLoad.length, dataToLoad[0].length).setValues(dataToLoad);
      newBackupSheet.getRange(2, 1, dataToLoad.length, newBackupSheet.getLastColumn()).setNumberFormat("@");
      Logger.log(`Data dimuat ke '${backupSheetName}'. Jumlah baris: ${dataToLoad.length}`);
    } else {
      Logger.log(`Tidak ada data valid dari klien untuk dimuat ke '${backupSheetName}'.`);
    }
    SpreadsheetApp.flush();

    const cleanupInfo = {
      sheetName: backupSheetName,
      teacherName: teacherName,
      lockId: lockId,
      deleteAt: Date.now() + (15 * 60 * 1000),
      status: "PENDING_NO_EXPORT"
    };
    PropertiesService.getScriptProperties().setProperty(`cleanup_${backupSheetName}`, JSON.stringify(cleanupInfo));
    Logger.log(`Penghapusan untuk '${backupSheetName}' dijadwalkan dalam 15 menit.`);
    createTriggerForCleanupIfNotExists();

    return { success: true, message: "LOCK_ID disimpan. Sheet cadangan disiapkan.", backupSheetName: backupSheetName };
  } catch (e) {
    Logger.log(`Error di saveLockIdAndPrepareBackupSheet: ${e.toString()} \nStack: ${e.stack}`);
    return { success: false, error: `Gagal memproses: ${e.message}` };
  }
}

function exportBackupSheetToExcel(backupSheetName, teacherName, bulanTahun, lockId) {
  try {
    SpreadsheetApp.flush();
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetToExport = ss.getSheetByName(backupSheetName);

    if (!sheetToExport) {
      return { success: false, error: `Sheet cadangan '${backupSheetName}' tidak ditemukan.` };
    }

    const spreadsheetId = ss.getId();
    const sheetId = sheetToExport.getSheetId();
    const internalExportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=xlsx&gid=${sheetId}`;
    const token = ScriptApp.getOAuthToken();
    const fetchParams = {
      headers: { 'Authorization': 'Bearer ' + token },
      muteHttpExceptions: true
    };
    const httpResponse = UrlFetchApp.fetch(internalExportUrl, fetchParams);

    if (httpResponse.getResponseCode() !== 200) {
      Logger.log(`Gagal mengambil blob Excel untuk '${backupSheetName}'. Kode: ${httpResponse.getResponseCode()}. Respon: ${httpResponse.getContentText()}`);
      return { success: false, error: `Gagal mengambil data Excel dari server (Status: ${httpResponse.getResponseCode()}).` };
    }
    const blob = httpResponse.getBlob();
    const bulanTahunFormattedForFilename = bulanTahun.replace('/', '-');
    const dynamicFileName = `Template_${teacherName}_${bulanTahunFormattedForFilename}_LOCK${lockId}.xlsx`;
    const base64Data = Utilities.base64Encode(blob.getBytes());
    const mimeType = blob.getContentType() || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';

    const cleanupKey = `cleanup_${backupSheetName}`;
    let cleanupInfo = PropertiesService.getScriptProperties().getProperty(cleanupKey);
    if (cleanupInfo) {
      cleanupInfo = JSON.parse(cleanupInfo);
      cleanupInfo.deleteAt = Date.now() + (1 * 60 * 1000);
      cleanupInfo.status = "EXPORTED_PENDING_DELETE";
      PropertiesService.getScriptProperties().setProperty(cleanupKey, JSON.stringify(cleanupInfo));
      Logger.log(`Penghapusan untuk '${backupSheetName}' dijadwalkan ulang dalam 1 menit setelah export.`);
    } else {
       const newCleanupInfo = {
        sheetName: backupSheetName, teacherName: teacherName, lockId: lockId,
        deleteAt: Date.now() + (1 * 60 * 1000),
        status: "EXPORTED_PENDING_DELETE_NO_PRIOR_RECORD"
      };
      PropertiesService.getScriptProperties().setProperty(`cleanup_${backupSheetName}`, JSON.stringify(newCleanupInfo));
      Logger.log(`Info cleanup tidak ditemukan untuk '${backupSheetName}', jadwal baru untuk penghapusan 1 menit.`);
    }
     createTriggerForCleanupIfNotExists();

    return {
      success: true, base64Data: base64Data, fileName: dynamicFileName,
      mimeType: mimeType, message: `Export untuk '${dynamicFileName}' dimulai.`
    };
  } catch (e) {
    Logger.log(`Error di exportBackupSheetToExcel: ${e.toString()} \nStack: ${e.stack}`);
    return { success: false, error: `Gagal mengekspor sheet cadangan: ${e.message}` };
  }
}

function autoCleanupBackupSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const properties = PropertiesService.getScriptProperties();
  const allKeys = properties.getKeys();
  const now = Date.now();
  let deletedCount = 0;

  allKeys.forEach(key => {
    if (key.startsWith("cleanup_")) {
      const backupSheetNameFromKey = key.substring("cleanup_".length);
      try {
        const infoString = properties.getProperty(key);
        if (infoString) {
          const info = JSON.parse(infoString);
          const sheetNameToDelete = info.sheetName || backupSheetNameFromKey;

          if (now >= info.deleteAt) {
            const sheet = ss.getSheetByName(sheetNameToDelete);
            if (sheet) {
              ss.deleteSheet(sheet);
              Logger.log(`Sheet cadangan '${sheetNameToDelete}' (Status: ${info.status}) otomatis dihapus.`);
              deletedCount++;
            } else {
              Logger.log(`Sheet cadangan '${sheetNameToDelete}' (Status: ${info.status}) tidak ditemukan untuk dihapus.`);
            }
            properties.deleteProperty(key);
          }
        }
      } catch (e) {
        Logger.log(`Error saat memproses cleanup untuk key '${key}': ${e.toString()}`);
      }
    }
  });
  if (deletedCount > 0) Logger.log(`${deletedCount} sheet cadangan berhasil dihapus oleh autoCleanup.`);

  const remainingCleanupKeys = properties.getKeys().filter(k => k.startsWith("cleanup_"));
  if (remainingCleanupKeys.length === 0) {
    deleteTriggerByName('autoCleanupBackupSheets');
    Logger.log("Tidak ada jadwal cleanup tersisa, trigger 'autoCleanupBackupSheets' dihapus.");
  }
}

function createTriggerForCleanupIfNotExists() {
  const triggers = ScriptApp.getProjectTriggers();
  let triggerExists = false;
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "autoCleanupBackupSheets") {
      triggerExists = true;
      break;
    }
  }
  if (!triggerExists) {
    ScriptApp.newTrigger("autoCleanupBackupSheets")
      .timeBased()
      .everyMinutes(5)
      .create();
    Logger.log("Trigger untuk 'autoCleanupBackupSheets' dibuat, berjalan setiap 5 menit.");
  }
}

function deleteTriggerByName(triggerHandlerFunctionName) {
  const triggers = ScriptApp.getProjectTriggers();
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === triggerHandlerFunctionName) {
      ScriptApp.deleteTrigger(triggers[i]);
      Logger.log(`Trigger dengan handler '${triggerHandlerFunctionName}' berhasil dihapus.`);
      break;
    }
  }
}

function changeUserPassword(username, oldPassword, newPassword) {
  try {
    if (!username) return { success: false, error: "Informasi pengguna tidak valid." };
    if (!oldPassword) return { success: false, error: "Password lama wajib diisi." };
    if (!newPassword || String(newPassword).length < 4) {
      return { success: false, error: "Password baru minimal 4 karakter." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    let rowIndex = -1;
    let actualOldPassword = "";

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === username) {
        rowIndex = i + 1;
        actualOldPassword = String(data[i][1]);
        break;
      }
    }
    if (rowIndex === -1) return { success: false, error: "Pengguna tidak ditemukan." };
    if (actualOldPassword !== oldPassword) return { success: false, error: "Password lama salah." };

    usersSheet.getRange(rowIndex, 2).setValue(newPassword);
    SpreadsheetApp.flush();
    return { success: true, message: "Password berhasil diubah." };
  } catch (e) {
    Logger.log(`Error in changeUserPassword for ${username}: ${e.toString()}`);
    return { success: false, error: `Gagal mengubah password: ${e.message}` };
  }
}

function linkCurrentUserToGoogle(customUsername) {
  try {
    if (!customUsername) {
      return { success: false, error: "Username kustom tidak diberikan." };
    }
    const activeUserEmail = Session.getActiveUser().getEmail();
    if (!activeUserEmail) {
      Logger.log(`Active user email: ${activeUserEmail}, Effective user: ${Session.getEffectiveUser().getEmail()}`);
      return { success: false, error: "Tidak dapat mengambil email akun Google Anda." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const headers = usersSheet.getRange(1, 1, 1, usersSheet.getLastColumn()).getValues()[0];
    const googleEmailColIdx = headers.indexOf("GoogleEmail"); // Kolom E (index 4)

    if (googleEmailColIdx === -1) {
        return { success: false, error: "Kolom 'GoogleEmail' tidak ditemukan di sheet Users." };
    }

    const data = usersSheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === customUsername) {
        rowIndex = i + 1;
        if (data[i][googleEmailColIdx] && String(data[i][googleEmailColIdx]).trim() !== "" && String(data[i][googleEmailColIdx]).trim() !== activeUserEmail) {
            return { success: false, error: `Akun '${customUsername}' sudah tertaut dengan email Google lain (${data[i][googleEmailColIdx]}).` };
        }
        if (String(data[i][googleEmailColIdx]).trim() === activeUserEmail) {
             return { success: true, message: `Akun Anda sudah tertaut dengan ${activeUserEmail}.`, linkedEmail: activeUserEmail };
        }
        break;
      }
    }
    if (rowIndex === -1) return { success: false, error: `Pengguna kustom '${customUsername}' tidak ditemukan.` };

    usersSheet.getRange(rowIndex, googleEmailColIdx + 1).setValue(activeUserEmail);
    SpreadsheetApp.flush();
    return { success: true, message: `Akun '${customUsername}' berhasil ditautkan dengan email Google: ${activeUserEmail}.`, linkedEmail: activeUserEmail };
  } catch (e) {
    Logger.log(`Error in linkCurrentUserToGoogle for ${customUsername}: ${e.toString()}`);
    return { success: false, error: `Gagal menautkan akun Google: ${e.message}` };
  }
}

function loginViaLinkedGoogleAccount() {
  try {
    const activeUserGoogleEmail = Session.getActiveUser().getEmail();
    if (!activeUserGoogleEmail) {
      Logger.log("Tidak dapat mengambil email Google pengguna aktif.");
      logUserActivity("ANONYMOUS", "ANONYMOUS", "LOGIN_GOOGLE_FAIL", "N/A", "Tidak dapat mengambil email Google pengguna aktif.", "FAIL");
      return { success: false, error: "Tidak dapat mengakses akun Google Anda." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
        // logUserActivity("SYSTEM", "N/A", "LOGIN_ERROR", "Sheet Users (Google Login)", "Sheet Users tidak ditemukan", "ERROR");
        return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const roleColIdx = headers.indexOf("role");
    const teacherNameColIdx = headers.indexOf("nama_guru_asli");
    const googleEmailColIdx = headers.indexOf("googleemail");
    const primaryEmailColIdx = headers.indexOf("primaryemail"); // Tambahkan ini

    if (googleEmailColIdx === -1 || usernameColIdx === -1 || roleColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Konfigurasi internal error: Kolom penting (Username/Role/GoogleEmail/PrimaryEmail) tidak ditemukan di sheet Users." };
    }

    for (let i = 1; i < data.length; i++) {
      const rowCustomUsername = String(data[i][usernameColIdx]).trim();
      const rowRole = String(data[i][roleColIdx]).trim();
      const rowActualTeacherName = data[i][teacherNameColIdx] ? String(data[i][teacherNameColIdx]).trim() : "";
      const linkedGoogleEmailInSheet = data[i][googleEmailColIdx] ? String(data[i][googleEmailColIdx]).trim() : "";
      const rowPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim() : null; // Ambil PrimaryEmail

      if (linkedGoogleEmailInSheet && linkedGoogleEmailInSheet.toLowerCase() === activeUserGoogleEmail.toLowerCase()) {
        let effectiveTeacherName = null;
        if (rowRole === ROLE_USER) {
          if (!rowActualTeacherName) {
            logUserActivity(rowCustomUsername, rowRole, "LOGIN_GOOGLE_WARN", rowCustomUsername, "Nama_Guru_Asli kosong", "WARN");
            return { success: false, error: `Login Google berhasil untuk '${activeUserGoogleEmail}', tetapi 'Nama_Guru_Asli' untuk akun '${rowCustomUsername}' kosong. Hubungi admin.` };
          }
          effectiveTeacherName = rowActualTeacherName;
          // ... (validasi nama guru di NAMA_GURU_SHEET_NAME seperti di verifyLogin) ...
           const sheetGuru = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
            if (sheetGuru) {
                const guruList = sheetGuru.getRange(1, 1, sheetGuru.getLastRow(), 1).getValues().flat().filter(String).map(g => String(g).trim());
                if (!guruList.includes(effectiveTeacherName)) {
                  logUserActivity(rowCustomUsername, rowRole, "LOGIN_GOOGLE_WARN", rowCustomUsername, `Nama Guru Asli '${effectiveTeacherName}' tidak valid`, "WARN");
                return { success: false, error: `Nama Guru Asli '${effectiveTeacherName}' (akun: ${rowCustomUsername}) tidak ada di sheet '${NAMA_GURU_SHEET_NAME}'.` };
                }
            } else {
                  logUserActivity(rowCustomUsername, rowRole, "LOGIN_GOOGLE_ERROR", rowCustomUsername, `Sheet Nama_Guru tidak ditemukan`, "ERROR");
                return { success: false, error: `Konfigurasi error: Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
            }
        }

        try {
          let loginHistorySheet = ensureSheet(LOGIN_HISTORY_SHEET_NAME, ["Username", "Login_Timestamp", "Nama_Guru", "Metode_Login"]);
          const timestamp = new Date();
          loginHistorySheet.appendRow([rowCustomUsername, timestamp, effectiveTeacherName || '', "Google"]);
          logUserActivity(rowCustomUsername, rowRole, "LOGIN_GOOGLE_SUCCESS", rowCustomUsername, `Role: ${rowRole}, EmailGoogle: ${activeUserGoogleEmail}`, "SUCCESS");
        } catch (logError) {
          Logger.log(`Gagal mencatat histori login Google untuk ${rowCustomUsername}: ${logError.toString()}`);
        }
        return {
          success: true,
          username: rowCustomUsername,
          role: rowRole,
          teacherName: effectiveTeacherName,
          googleEmail: activeUserGoogleEmail,
          primaryEmail: rowPrimaryEmail // <-- TAMBAHKAN INI
        };
      }
    }
    logUserActivity(activeUserGoogleEmail, "ANONYMOUS", "LOGIN_GOOGLE_FAIL", activeUserGoogleEmail, "Akun Google tidak tertaut", "FAIL");
    return { success: false, error: `Akun Google Anda (${activeUserGoogleEmail}) tidak tertaut dengan akun manapun di sistem ini.` };
  } catch (e) {
    Logger.log(`Error in loginViaLinkedGoogleAccount: ${e.toString()}`);
    const userEmailForLog = typeof activeUserGoogleEmail !== 'undefined' ? activeUserGoogleEmail : "ANONYMOUS_GOOGLE_ERROR";
    logUserActivity(userEmailForLog, "ANONYMOUS", "LOGIN_GOOGLE_SYSTEM_ERROR", userEmailForLog, e.message, "ERROR");
    return { success: false, error: `Error server saat login Google: ${e.message}` };
  }
}

function unlinkCurrentUserFromGoogle(customUsername) {
  try {
    if (!customUsername) {
      return { success: false, error: "Username kustom tidak diberikan." };
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const headers = usersSheet.getRange(1, 1, 1, usersSheet.getLastColumn()).getValues()[0];
    const googleEmailColIdx = headers.indexOf("GoogleEmail"); // Kolom E (index 4)
    if (googleEmailColIdx === -1) {
      return { success: false, error: "Kolom 'GoogleEmail' tidak ditemukan di sheet Users (backend)." };
    }

    const data = usersSheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === customUsername) {
        rowIndex = i + 1;
        break;
      }
    }
    if (rowIndex === -1) return { success: false, error: `Pengguna kustom '${customUsername}' tidak ditemukan.` };

    usersSheet.getRange(rowIndex, googleEmailColIdx + 1).setValue('');
    SpreadsheetApp.flush();
    return { success: true, message: `Hubungan akun Google untuk '${customUsername}' berhasil diputuskan.` };
  } catch (e) {
    Logger.log(`Error in unlinkCurrentUserFromGoogle for ${customUsername}: ${e.toString()}`);
    return { success: false, error: `Gagal memutuskan hubungan akun Google: ${e.message}` };
  }
}

// Tambahkan fungsi ini di Code.gs

/**
 * Mengambil data rekapitulasi ceklok bulanan yang dinamis untuk semua guru.
 *
 * @param {string} selectedMonthYear Periode bulan dan tahun yang dipilih (format "MM/YYYY").
 * @return {Object} Objek yang berisi data rekapitulasi atau objek error.
 * Contoh struktur sukses:
 * {
 * success: true,
 * bulanTahunRekap: "05/2025",
 * jumlahHari: 31,
 * daftarHeaderTanggal: ["1", "2", ..., "31"], // Header untuk kolom tanggal
 * daftarGuru: [ // Array objek guru dengan data cekloknya
 * {
 * nama: "Nama Guru A",
 * absensi: [ // Array data absensi, urut per tanggal
 * { tanggalFormatted: "01/05", jamMasuk: "07.00", jamPulang: "14.00", keterangan: "", isLibur: false, cssClass: "" },
 * { tanggalFormatted: "02/05", jamMasuk: "-", jamPulang: "-", keterangan: "Libur Nasional", isLibur: true, cssClass: "libur-nasional" },
 * { tanggalFormatted: "03/05", jamMasuk: "S", jamPulang: "S", keterangan: "Sakit", isLibur: false, cssClass: "keterangan-manual" },
 * // ... dan seterusnya untuk semua tanggal di bulan tersebut
 * ]
 * },
 * // ... objek untuk guru lainnya
 * ]
 * }
 */
function getDynamicMonthlyRekap(selectedMonthYear) {
  try {
    // Validasi input selectedMonthYear
    if (!selectedMonthYear || !/^\d{2}\/\d{4}$/.test(selectedMonthYear)) {
      return { success: false, error: "Format Bulan/Tahun untuk rekap tidak valid (MM/YYYY)." };
    }

    // Validasi terhadap batasan global (opsional tapi baik)
    const settings = getCeklokInputSettings(); // Gunakan fungsi yang sudah ada
    if (settings.success) {
      const parseMY = (myStr) => { const [m, y] = myStr.split('/'); return new Date(parseInt(y), parseInt(m) - 1, 1); };
      const reqDate = parseMY(selectedMonthYear);
      if (reqDate < parseMY(settings.adminDefinedMinMonthYear) || reqDate > parseMY(settings.serverCurrentMonthYear)) {
        return { success: false, error: `Periode ${selectedMonthYear} di luar rentang yang diizinkan (${settings.adminDefinedMinMonthYear} - ${settings.serverCurrentMonthYear}).` };
      }
    } else {
      Logger.log(`Peringatan di getDynamicMonthlyRekap: Gagal mengambil settings global untuk validasi - ${settings.error}`);
      // Tetap lanjutkan jika settings tidak krusial untuk fungsi inti ini,
      // karena validasi utama ada di client sebelum memanggil.
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const kalenderSheet = ss.getSheetByName(KALENDER_SHEET_NAME);

    if (!namaGuruSheet) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (!ceklokManualSheet) return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };
    if (!kalenderSheet) return { success: false, error: `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan.` };

    // 1. Ambil daftar semua guru
    const daftarNamaGuru = namaGuruSheet.getLastRow() > 0 ?
                           namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1)
                                      .getValues().flat().filter(String).map(g => g.trim()) :
                           [];
    if (daftarNamaGuru.length === 0) {
      return { success: true, bulanTahunRekap: selectedMonthYear, jumlahHari: 0, daftarHeaderTanggal: [], daftarGuru: [], message: "Tidak ada data guru untuk ditampilkan." };
    }

    // 2. Persiapkan data untuk bulan yang dipilih
    const [mmStr, yyyyStr] = selectedMonthYear.split('/');
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(yyyyStr, 10);
    const jumlahHari = new Date(yyyy, mm, 0).getDate();
    const daftarHeaderTanggal = Array.from({ length: jumlahHari }, (_, i) => String(i + 1));

    // 3. Ambil data libur dari Kalender Pendidikan
    const liburKalenderMap = {}; // Key: "dd/MM/yyyy", Value: Keterangan Libur
    if (kalenderSheet.getLastRow() > 1) {
      const kalenderData = kalenderSheet.getRange(2, 1, kalenderSheet.getLastRow() - 1, 2).getDisplayValues();
      kalenderData.forEach(row => {
        if (row[0] && row[0].trim() !== "") {
          // Pastikan hanya data dari bulan dan tahun yang relevan
          const tglParts = row[0].split('/');
          if (tglParts.length === 3 && parseInt(tglParts[1]) === mm && parseInt(tglParts[2]) === yyyy) {
            liburKalenderMap[row[0].trim()] = row[1].trim() || "Hari Libur";
          }
        }
      });
    }

    // 4. Ambil semua data dari Ceklok_Manual untuk efisiensi
    const ceklokManualData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = ceklokManualData[0].map(h => String(h).trim());
    const idxNama = ceklokHeaders.indexOf("Nama_Guru");
    const idxTanggal = ceklokHeaders.indexOf("Tanggal");
    const idxMasuk = ceklokHeaders.indexOf("Jam_Masuk");
    const idxPulang = ceklokHeaders.indexOf("Jam_Pulang");
    const idxKetManual = ceklokHeaders.indexOf("Ket_Libur_Manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap/tidak sesuai." };
    }

    // 5. Proses data per guru
    const hasilRekapGuru = [];
    const namaHariIndonesia = ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"];
    const HARI_LIBUR_SEKOLAH_TEXT = "Hari Libur Sekolah"; // Definisikan konstanta untuk menghindari typo

    for (const namaGuru of daftarNamaGuru) {
      const dataAbsensiGuru = [];
      for (let tgl = 1; tgl <= jumlahHari; tgl++) {
        const currentDate = new Date(yyyy, mm - 1, tgl);
        const tanggalFullStr = Utilities.formatDate(currentDate, Session.getScriptTimeZone(), "dd/MM/yyyy");
        const tanggalFormattedUntukTooltip = Utilities.formatDate(currentDate, Session.getScriptTimeZone(), "dd MMM yyyy"); // Untuk tooltip
        const hariDalamMinggu = currentDate.getDay(); 

        let jamMasukDisplay = "-";
        let jamPulangDisplay = "-";
        let keteranganDisplay = "";
        let isLiburHariIni = false;
        let cssClass = "";

        // Cek apakah hari Minggu
        if (hariDalamMinggu === 0) { 
          isLiburHariIni = true;
          keteranganDisplay = "Minggu";
          cssClass = "libur-minggu";
        }

        // Cek libur dari Kalender Pendidikan (menimpa jika bukan Minggu tapi ada di kalender)
        if (liburKalenderMap[tanggalFullStr]) {
          isLiburHariIni = true;
          // Jika sudah "Minggu" dan ada libur kalender, keterangan libur kalender lebih prioritas
          keteranganDisplay = liburKalenderMap[tanggalFullStr]; 
          cssClass = "libur-kalender"; 
        }

        // Cari data di Ceklok_Manual
        let dataCeklokUntukHariIni = null;
        for (let k = 1; k < ceklokManualData.length; k++) { 
          const row = ceklokManualData[k];
          if (String(row[idxNama]).trim() === namaGuru &&
              row[idxTanggal] instanceof Date &&
              Utilities.formatDate(new Date(row[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === tanggalFullStr) {
            dataCeklokUntukHariIni = row;
            break;
          }
        }
        
        if (dataCeklokUntukHariIni) {
          const ketManual = String(dataCeklokUntukHariIni[idxKetManual] || "").trim();
          
          if (ketManual !== "") {
            // Jika ada keterangan manual, itu yang utama
            // isLiburHariIni tetap true jika memang hari Minggu atau Libur Kalender,
            // tapi tampilan jam akan mengikuti ketManual.
            
            if (ketManual.trim().toLowerCase() === HARI_LIBUR_SEKOLAH_TEXT.trim().toLowerCase()) {
              jamMasukDisplay = "-";
              jamPulangDisplay = "-";
            } else {
              jamMasukDisplay = "-";
              jamPulangDisplay = "-";
            }
            
            // Update keteranganDisplay dan cssClass jika ada ketManual
            if (isLiburHariIni) { // Jika ini hari Minggu/Libur Kalender DAN ada ket. manual
                 keteranganDisplay = `${keteranganDisplay} (${ketManual})`; // Gabungkan info libur dan keterangan manual
            } else { // Jika hari kerja dan ada ket. manual
                keteranganDisplay = ketManual; // Keterangan utama adalah keterangan manual
                cssClass = "keterangan-manual"; 
            }
            // Jika ketManual ada, kita tidak lagi menganggapnya sebagai "hadir" murni
            // jadi jika sebelumnya cssClass adalah "hadir", kita timpa.
            // Jika cssClass sudah "libur-minggu" atau "libur-kalender", kita biarkan
            // dan hanya tambahkan "(ketManual)" pada keteranganDisplay.
            if (cssClass !== "libur-minggu" && cssClass !== "libur-kalender") {
                cssClass = "keterangan-manual";
            }

          } else if (!isLiburHariIni) { // Tidak ada ket. manual DAN BUKAN hari libur (Minggu/Kalender)
            jamMasukDisplay = String(dataCeklokUntukHariIni[idxMasuk] || "").trim() || "-";
            jamPulangDisplay = String(dataCeklokUntukHariIni[idxPulang] || "").trim() || "-";
            if (jamMasukDisplay !== "-" || jamPulangDisplay !== "-") {
                cssClass = "hadir"; // Ini adalah kondisi hadir murni
            }
          }
          // Jika tidak ada ketManual dan INI ADALAH hari libur (Minggu/Kalender), 
          // jamMasukDisplay dan jamPulangDisplay tetap "-" (default awal).
        }
        // Jika tidak ada dataCeklokUntukHariIni dan ini adalah hari libur,
        // jamMasukDisplay dan jamPulangDisplay tetap "-" (default awal).
        // Jika tidak ada dataCeklokUntukHariIni dan ini BUKAN hari libur (hari kerja kosong),
        // jamMasukDisplay dan jamPulangDisplay juga tetap "-" (default awal).

        dataAbsensiGuru.push({
          tanggalFormatted: String(tgl), 
          tanggalFullStr: tanggalFormattedUntukTooltip, // Tambahkan ini untuk tooltip yang lebih informatif
          namaHari: namaHariIndonesia[hariDalamMinggu], 
          jamMasuk: jamMasukDisplay,
          jamPulang: jamPulangDisplay,
          keterangan: keteranganDisplay,
          isLibur: isLiburHariIni, // Ini tetap menandakan apakah HARI-nya libur secara kalender/minggu
          cssClass: cssClass
        });
      }
      hasilRekapGuru.push({ nama: namaGuru, absensi: dataAbsensiGuru });
    }

    return {
      success: true,
      bulanTahunRekap: selectedMonthYear,
      jumlahHari: jumlahHari,
      daftarHeaderTanggal: daftarHeaderTanggal,
      daftarGuru: hasilRekapGuru
    };

  } catch (e) {
    Logger.log(`Error di getDynamicMonthlyRekap untuk periode ${selectedMonthYear}: ${e.toString()}\nStack: ${e.stack}`);
    return { success: false, error: `Gagal mengambil data rekapitulasi bulanan: ${e.message}` };
  }
}

function formatTimeToHHMM_or_Empty(timeStr) {
  if (!timeStr || String(timeStr).trim() === "" || String(timeStr).trim() === "-") {
    return "";
  }
  const parts = String(timeStr).trim().split(/[.:]/);
  if (parts.length === 2) {
    const h = String(parts[0]).padStart(2, '0');
    const m = String(parts[1]).padStart(2, '0');
    if (!isNaN(parseInt(h, 10)) && !isNaN(parseInt(m, 10)) &&
        parseInt(h, 10) >= 0 && parseInt(h, 10) < 24 &&
        parseInt(m, 10) >= 0 && parseInt(m, 10) < 60) {
      return `${h}.${m}`;
    }
  }
  // Logger.log("Format jam tidak valid, dikembalikan kosong: " + timeStr); // Kurangi logging di produksi
  return "";
}


/**
 * Membuat atau memastikan trigger untuk autoCleanupTemporarySheets ada.
 */
function createOrEnsureCleanupTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  let triggerExists = false;
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "autoCleanupTemporarySheets") {
      triggerExists = true;
      break;
    }
  }
  if (!triggerExists) {
    ScriptApp.newTrigger("autoCleanupTemporarySheets")
      .timeBased()
      .everyMinutes(5) // Jalankan setiap 5 menit
      .create();
    Logger.log("Trigger untuk autoCleanupTemporarySheets berhasil dibuat.");
  }
}

/**
 * Menjadwalkan penghapusan sheet sementara.
 * @param {string} sheetName Nama sheet yang akan dihapus.
 * @param {number} delayMinutes Jumlah menit sebelum sheet dihapus.
 */
function scheduleTemporarySheetDeletion(sheetName, delayMinutes) {
  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    const deletionTime = new Date().getTime() + (delayMinutes * 60 * 1000);
    scriptProperties.setProperty(`DELETE_${sheetName}`, deletionTime.toString());
    createOrEnsureCleanupTrigger(); // Pastikan trigger pembersihan ada
    Logger.log(`Penghapusan untuk sheet '${sheetName}' dijadwalkan dalam ${delayMinutes} menit.`);
  } catch (e) {
    Logger.log(`Gagal menjadwalkan penghapusan untuk sheet '${sheetName}': ${e.toString()}`);
  }
}

/**
 * Secara otomatis membersihkan sheet sementara yang sudah dijadwalkan untuk dihapus.
 * Fungsi ini akan dijalankan oleh trigger berbasis waktu.
 */
function autoCleanupTemporarySheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const scriptProperties = PropertiesService.getScriptProperties();
  const properties = scriptProperties.getProperties();
  const currentTime = new Date().getTime();
  let deletedCount = 0;

  for (const key in properties) {
    if (key.startsWith("DELETE_")) {
      const sheetName = key.substring("DELETE_".length);
      const deletionTime = parseInt(properties[key], 10);

      if (currentTime >= deletionTime) {
        try {
          const sheetToDelete = ss.getSheetByName(sheetName);
          if (sheetToDelete) {
            ss.deleteSheet(sheetToDelete);
            Logger.log(`Sheet sementara '${sheetName}' berhasil dihapus secara otomatis.`);
            deletedCount++;
          } else {
            Logger.log(`Sheet sementara '${sheetName}' tidak ditemukan untuk dihapus (mungkin sudah dihapus).`);
          }
          scriptProperties.deleteProperty(key);
        } catch (e) {
          Logger.log(`Error saat mencoba menghapus sheet '${sheetName}': ${e.toString()}`);
          // Pertimbangkan untuk tidak menghapus properti jika ada error, agar bisa dicoba lagi
          // atau hapus properti agar tidak terus mencoba sheet yang bermasalah
          scriptProperties.deleteProperty(key);
        }
      }
    }
  }
  if (deletedCount > 0) {
      Logger.log(`${deletedCount} sheet sementara telah dihapus.`);
  }
  // Jika tidak ada lagi properti DELETE_, trigger bisa dihapus untuk menghemat kuota trigger
  const remainingDeleteKeys = Object.keys(scriptProperties.getProperties()).filter(k => k.startsWith("DELETE_"));
  if (remainingDeleteKeys.length === 0) {
      const triggers = ScriptApp.getProjectTriggers();
      for (let i = 0; i < triggers.length; i++) {
          if (triggers[i].getHandlerFunction() === "autoCleanupTemporarySheets") {
              ScriptApp.deleteTrigger(triggers[i]);
              Logger.log("Tidak ada jadwal penghapusan sheet, trigger autoCleanupTemporarySheets dihapus.");
              break;
          }
      }
  }
}


/**
 * Membuat duplikat sheet CETAK, mengisinya dengan data rekap,
 * melakukan formatting, dan mengembalikan info sheet duplikat.
 * @param {string} selectedMonthYear Periode bulan dan tahun (format "MM/YYYY").
 * @return {object} Objek berisi {success, sheetName, sheetId, lastDataRow, lastDataCol, message/error}.
 */
function generatePrintableSheet(selectedMonthYear) {
  try {
    // 1. Validasi input dan persiapan periode (kode dari prepareMonthlyRekapForPrint sebelumnya)
    if (!selectedMonthYear || !/^\d{2}\/\d{4}$/.test(selectedMonthYear)) {
      return { success: false, error: "Format Bulan/Tahun untuk cetak tidak valid (MM/YYYY)." };
    }
    const settings = getCeklokInputSettings(); // Asumsi fungsi ini ada
    if (settings.success) {
      const parseMY = (myStr) => { 
        if (!myStr || !myStr.includes('/')) return null;
        const [m, y] = myStr.split('/'); 
        if (isNaN(parseInt(m)) || isNaN(parseInt(y))) return null;
        return new Date(parseInt(y), parseInt(m) - 1, 1); 
      };
      const reqDate = parseMY(selectedMonthYear);
      const minDate = parseMY(settings.adminDefinedMinMonthYear);
      const maxDate = parseMY(settings.serverCurrentMonthYear);
      if (reqDate && minDate && reqDate < minDate) {
        return { success: false, error: `Periode cetak ${selectedMonthYear} di luar rentang (${settings.adminDefinedMinMonthYear} - ${settings.serverCurrentMonthYear}).` };
      }
      if (reqDate && maxDate && reqDate > maxDate) {
         return { success: false, error: `Periode cetak ${selectedMonthYear} di luar rentang (${settings.adminDefinedMinMonthYear} - ${settings.serverCurrentMonthYear}).` };
      }
    } else {
      Logger.log(`Peringatan di generatePrintableSheet: Gagal mengambil settings - ${settings.error}`);
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const templateSheet = ss.getSheetByName(CETAK_TEMPLATE_SHEET_NAME);
    const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);

    if (!templateSheet) return { success: false, error: `Sheet template '${CETAK_TEMPLATE_SHEET_NAME}' tidak ditemukan.` };
    if (!namaGuruSheet) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (!ceklokManualSheet) return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };

    const daftarNamaGuru = namaGuruSheet.getLastRow() > 0 ?
                           namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1)
                                      .getValues().flat().filter(String).map(g => String(g).trim()) :
                           [];
    if (daftarNamaGuru.length === 0) {
      // Tidak perlu menulis ke C2 jika tidak ada guru, cukup return error agar UI tahu
      return { success: false, error: "Tidak ada data nama guru di sheet 'Nama_Guru'." };
    }

    const [mmStr, yyyyStr] = selectedMonthYear.split('/');
    const mm = parseInt(mmStr, 10); // 1-12
    const yyyy = parseInt(yyyyStr, 10);
    
    const tanggalAwalObj = new Date(yyyy, mm - 1, 1); // mm-1 karena bulan di JS 0-indexed
    const tanggalAkhirObj = new Date(yyyy, mm, 0); 
    const jumlahHariValid = tanggalAkhirObj.getDate(); // Ini sudah benar, misal Mei 2025 -> 31

    const tanggalAwalFormatted = Utilities.formatDate(tanggalAwalObj, Session.getScriptTimeZone(), "yyyy-MM-dd");
    const tanggalAkhirFormatted = Utilities.formatDate(tanggalAkhirObj, Session.getScriptTimeZone(), "yyyy-MM-dd");

    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd_HHmmss_SSS");
    const userEmailPart = (Session.getActiveUser().getEmail() || "unknownuser").split('@')[0].replace(/[^a-zA-Z0-9]/g, '');
    const duplicateSheetName = `${TEMP_SHEET_PREFIX}${timestamp}_${userEmailPart}`;
    
    const printableSheet = templateSheet.copyTo(ss).setName(duplicateSheetName);
    printableSheet.activate();
    SpreadsheetApp.flush();

    printableSheet.getRange("C2").setValue(`${tanggalAwalFormatted} ~ ${tanggalAkhirFormatted}`);
    printableSheet.getRange("L2").setValue(tanggalAkhirFormatted);

    // --- Mengisi nomor tanggal di baris ke-3 (A3-AE3) dan Set Column Width ---
    const BARIS_HEADER_TANGGAL = 3;
    const KOLOM_TANGGAL_PERTAMA = 1; // Kolom A
    const JUMLAH_KOLOM_TANGGAL_MAX = 31; // AE adalah kolom ke-31

    const headerTanggalArray = [];
    for (let i = 1; i <= JUMLAH_KOLOM_TANGGAL_MAX; i++) {
      if (i <= jumlahHariValid) {
        headerTanggalArray.push(i); // Isi dengan nomor tanggal
        try { printableSheet.setColumnWidth(KOLOM_TANGGAL_PERTAMA + i - 1, 44); } catch(e){ Logger.log("Gagal setColumnWidth 44 untuk kolom " + (KOLOM_TANGGAL_PERTAMA + i - 1) + ": " + e.message)}
      } else {
        headerTanggalArray.push(""); // Kosongkan jika tanggal tidak valid untuk bulan ini
        try { printableSheet.setColumnWidth(KOLOM_TANGGAL_PERTAMA + i - 1, 24); } catch(e){ Logger.log("Gagal setColumnWidth 24 untuk kolom " + (KOLOM_TANGGAL_PERTAMA + i - 1) + ": " + e.message)}
      }
    }
    printableSheet.getRange(BARIS_HEADER_TANGGAL, KOLOM_TANGGAL_PERTAMA, 1, JUMLAH_KOLOM_TANGGAL_MAX).setValues([headerTanggalArray])
                  .setHorizontalAlignment("center");


    const ceklokManualData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = ceklokManualData[0].map(h => String(h).trim());
    // ... (idxNama, idxTanggal, dll. sama seperti sebelumnya) ...
    const idxNama = ceklokHeaders.indexOf("Nama_Guru");
    const idxTanggal = ceklokHeaders.indexOf("Tanggal");
    const idxMasuk = ceklokHeaders.indexOf("Jam_Masuk");
    const idxPulang = ceklokHeaders.indexOf("Jam_Pulang");
    const idxKetManual = ceklokHeaders.indexOf("Ket_Libur_Manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      ss.deleteSheet(printableSheet);
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap." };
    }

    const BARIS_MULAI_DATA_GURU_DI_TEMPLATE = 4;
    if (printableSheet.getLastRow() >= BARIS_MULAI_DATA_GURU_DI_TEMPLATE) {
        printableSheet.getRange(BARIS_MULAI_DATA_GURU_DI_TEMPLATE, 1, printableSheet.getMaxRows() - BARIS_MULAI_DATA_GURU_DI_TEMPLATE + 1, printableSheet.getMaxColumns())
                      .clearContent();
    }

    let barisSaatIni = BARIS_MULAI_DATA_GURU_DI_TEMPLATE;
    let lastDataRowForPdf = barisSaatIni -1; 

    daftarNamaGuru.forEach((namaGuru, index) => {
      printableSheet.getRange(barisSaatIni, 1).setValue("ID:").setHorizontalAlignment("left");       // A
      printableSheet.getRange(barisSaatIni, 3).setValue(index + 1).setHorizontalAlignment("center"); // C
      printableSheet.getRange(barisSaatIni, 9).setValue("Nama:").setHorizontalAlignment("left");    // I
      printableSheet.getRange(barisSaatIni, 11).setValue(namaGuru).setHorizontalAlignment("left");   // K
      printableSheet.getRange(barisSaatIni, 19).setValue("Dept.:").setHorizontalAlignment("left");  // S
      printableSheet.getRange(barisSaatIni, 21).setValue("MTS~TANUNTUNG").setHorizontalAlignment("left"); // U

      const barisJamMasuk = barisSaatIni + 1;
      const barisJamPulang = barisSaatIni + 2;
      
      // Inisialisasi array sepanjang JUMLAH_KOLOM_TANGGAL_MAX (31)
      const arrayJamMasuk = new Array(JUMLAH_KOLOM_TANGGAL_MAX).fill("");
      const arrayJamPulang = new Array(JUMLAH_KOLOM_TANGGAL_MAX).fill("");

      for (let tgl = 1; tgl <= jumlahHariValid; tgl++) { // Loop hanya sampai jumlah hari yang valid
        const tanggalCeklokStr = Utilities.formatDate(new Date(yyyy, mm - 1, tgl), Session.getScriptTimeZone(), "dd/MM/yyyy");
        let jamMasukUntukHariIni = ""; 
        let jamPulangUntukHariIni = "";
        
        const dataCeklokHariIni = ceklokManualData.find(row =>
          String(row[idxNama]).trim() === namaGuru &&
          row[idxTanggal] instanceof Date && // Penting: pastikan data di sheet adalah objek Date
          Utilities.formatDate(new Date(row[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === tanggalCeklokStr
        );

        if (dataCeklokHariIni) {
          const ketManual = String(dataCeklokHariIni[idxKetManual] || "").trim();
          if (ketManual === "") { 
            jamMasukUntukHariIni = formatTimeToHHMM_or_Empty(String(dataCeklokHariIni[idxMasuk] || "").trim());
            jamPulangUntukHariIni = formatTimeToHHMM_or_Empty(String(dataCeklokHariIni[idxPulang] || "").trim());
          }
        }
        // Tulis ke array pada indeks yang sesuai dengan tanggal (tgl-1 karena array 0-indexed)
        arrayJamMasuk[tgl - 1] = jamMasukUntukHariIni; 
        arrayJamPulang[tgl - 1] = jamPulangUntukHariIni;
      }
      
      // Tulis seluruh baris jam masuk dan jam pulang (array sudah sepanjang 31)
      printableSheet.getRange(barisJamMasuk, KOLOM_TANGGAL_PERTAMA, 1, JUMLAH_KOLOM_TANGGAL_MAX).setValues([arrayJamMasuk])
                  .setHorizontalAlignment("center").setNumberFormat("@");
      printableSheet.getRange(barisJamPulang, KOLOM_TANGGAL_PERTAMA, 1, JUMLAH_KOLOM_TANGGAL_MAX).setValues([arrayJamPulang])
                  .setHorizontalAlignment("center").setNumberFormat("@");
      
      lastDataRowForPdf = barisJamPulang;
      barisSaatIni += 3;
    });

    // Kolom terakhir yang akan dicetak adalah kolom ke-31 (AE), karena template Anda A3-AE5
    // Atau jika Anda ingin lebih dinamis berdasarkan jumlah hari: KOLOM_TANGGAL_PERTAMA + jumlahHariValid - 1;
    // Namun, karena template sampai AE, kita gunakan AE saja.
    const lastDataColForPdf = JUMLAH_KOLOM_TANGGAL_MAX; 

    SpreadsheetApp.flush();
    scheduleTemporarySheetDeletion(duplicateSheetName, 2);

    return { 
      success: true, 
      message: `Sheet sementara '${duplicateSheetName}' berhasil disiapkan.`,
      sheetName: duplicateSheetName,
      sheetId: printableSheet.getSheetId(),
      lastDataRow: lastDataRowForPdf, 
      lastDataCol: lastDataColForPdf
    };

  } catch (e) {
    Logger.log(`Error di generatePrintableSheet untuk periode ${selectedMonthYear}: ${e.toString()}\nStack: ${e.stack}`);
    if (typeof printableSheet !== 'undefined' && printableSheet && SpreadsheetApp.getActiveSpreadsheet().getSheetByName(printableSheet.getName())) {
        SpreadsheetApp.getActiveSpreadsheet().deleteSheet(printableSheet);
        Logger.log("Sheet duplikat yang gagal diproses telah dihapus.");
    }
    return { success: false, error: `Gagal menyiapkan data cetak: ${e.message}` };
  }
}


/**
 * Mengekspor sheet tertentu ke PDF dengan print area yang disesuaikan.
 * @param {string} sheetIdToPrint ID dari sheet yang akan diekspor.
 * @param {number} printRowCount Jumlah baris yang akan dicetak.
 * @param {number} printColCount Jumlah kolom yang akan dicetak.
 * @return {object} Objek berisi URL PDF atau error.
 */
function downloadSheetAsPDF(sheetIdToPrint, printRowCount, printColCount) {
  try {
    if (!sheetIdToPrint || !printRowCount || !printColCount) {
        return { error: "Parameter untuk download PDF tidak lengkap."};
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheets().find(s => s.getSheetId() == sheetIdToPrint);

    if (!sheet) {
      return { error: `Sheet dengan ID '${sheetIdToPrint}' tidak ditemukan untuk PDF.` };
    }
    
    const sheetName = sheet.getName(); // Dapatkan nama sheet untuk filename PDF
    const fileName = `${sheetName}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd")}.pdf`;

    // Mengatur print area (A1 notation)
    // Kolom terakhir adalah printColCount, Baris terakhir adalah printRowCount
    const printAreaRange = `A1:${getCellA1Notation(printRowCount, printColCount)}`;
    Logger.log("Print Area: " + printAreaRange);


    const exportUrl = ss.getUrl().replace(/edit$/, '') + 'export?';
    const params = {
      format: 'pdf',
      portrait: false, // Lanskap biasanya lebih cocok untuk tabel lebar
      size: 'A4',      // Atau 'letter', dll.
      fitw: true,      // Fit to width
      // scale: 1, // Skala Normal (100%)
      top_margin: 0.5,
      bottom_margin: 0.5,
      left_margin: 0.5,
      right_margin: 0.5,
      sheetnames: false,
      printtitle: false,
      pagenumbers: false,
      gridlines: false, // Biasanya false untuk tampilan cetak yang bersih
      fzr: false,       // Freeze rows = false
      fzc: false,       // Freeze columns = false
      gid: sheetIdToPrint,
      // Menambahkan parameter untuk print area (jika didukung, seringkali r1,c1,r2,c2 lebih reliable)
      // Namun, parameter export Google Sheets tidak secara langsung mendukung 'printAreaRange' via A1.
      // Kita akan mengandalkan `fitw` dan batasan data yang ditulis ke sheet sementara.
      // Jika ingin kontrol print area lebih presisi, cara alternatif adalah membuat file Google Docs/Slides
      // dari data, lalu ekspor ke PDF, atau menggunakan API pihak ketiga.

      // Untuk PDF export, kita lebih banyak mengontrol data YANG ADA di sheet sementara.
      // Pastikan sheet sementara hanya berisi data hingga printRowCount dan printColCount.
      // Parameter di bawah ini untuk export CSV/TSV, mungkin tidak berlaku untuk PDF tapi dicoba:
      // 'c1': 0, // Kolom mulai (0-indexed)
      // 'r1': 0, // Baris mulai (0-indexed)
      // 'c2': printColCount -1,
      // 'r2': printRowCount -1
    };

    // Hapus kolom dan baris ekstra di sheet sementara jika ada, sebelum export
    // Ini lebih efektif daripada parameter URL untuk PDF
    if (sheet.getMaxColumns() > printColCount) {
        sheet.deleteColumns(printColCount + 1, sheet.getMaxColumns() - printColCount);
    }
    if (sheet.getMaxRows() > printRowCount) {
        sheet.deleteRows(printRowCount + 1, sheet.getMaxRows() - printRowCount);
    }
    SpreadsheetApp.flush();


    const query = Object.entries(params).map(([k, v]) => `${k}=${v}`).join('&');
    const blob = UrlFetchApp.fetch(exportUrl + query, {
      headers: { Authorization: 'Bearer ' + ScriptApp.getOAuthToken() },
      muteHttpExceptions: true
    }).getBlob().setName(fileName);

    if (blob.getContentType() !== "application/pdf") {
        Logger.log("Gagal membuat PDF, respons bukan PDF. Konten: " + blob.getDataAsString());
        return { error: "Gagal membuat PDF dari server. Respons bukan PDF."};
    }

    // Simpan ke Drive sementara agar bisa dapat URL publik (jika diperlukan untuk direct link)
    // Atau langsung kirim sebagai base64 jika frontend bisa handle.
    // Untuk window.open, kita perlu URL yang bisa diakses.
    // Namun, karena kita akan menghapus sheet, membuat file di Drive mungkin tidak ideal.
    // Coba langsung buat data URL jika frontend bisa (tapi window.open biasanya butuh http URL)
    // Untuk saat ini, kita kembalikan data untuk dibuat file di frontend jika mau,
    // atau kita bisa buat file di Drive dan berikan linknya.
    // Paling sederhana: kembalikan base64 dan biarkan frontend membuat blob & link download.

    // Menggunakan Google Drive untuk mendapatkan URL yang dapat diunduh
    const tempFolder = DriveApp.getFoldersByName("TempPdfCeklok").hasNext() ? DriveApp.getFoldersByName("TempPdfCeklok").next() : DriveApp.createFolder("TempPdfCeklok");
    const pdfFile = tempFolder.createFile(blob);
    const downloadUrl = pdfFile.getDownloadUrl().replace("&exportFormat=pdf", ""); // URL untuk diunduh

    // Jadwalkan penghapusan file PDF dari Drive juga (opsional, tapi baik)
    // Ini memerlukan mekanisme cleanup Drive File terpisah jika diinginkan.
    // Untuk sekarang, fokus pada penghapusan sheet.

    return { success: true, downloadUrl: downloadUrl, fileName: fileName };

  } catch (e) {
    Logger.log(`Error downloadSheetAsPDF: ${e.toString()}\nStack: ${e.stack}`);
    return { error: `Gagal membuat PDF: ${e.message}` };
  }
}

/**
 * Helper untuk mendapatkan notasi A1 dari nomor baris dan kolom.
 * @param {number} row Nomor baris (1-indexed).
 * @param {number} col Nomor kolom (1-indexed).
 * @return {string} Notasi A1, contoh "AE5".
 */
function getCellA1Notation(row, col) {
  let columnName = "";
  let dividend = col;
  let modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % 26;
    columnName = String.fromCharCode(65 + modulo) + columnName;
    dividend = Math.floor((dividend - modulo) / 26);
  }
  return columnName + row;
}

// Di dalam code.gs.html
function saveUserPrimaryEmail(username, primaryEmail) {
  try {
    if (!username || !primaryEmail) {
      return { success: false, error: "Username dan Email tidak boleh kosong." };
    }

    // Validasi format email dasar di server
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(primaryEmail)) {
      return { success: false, error: "Format email tidak valid." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
      return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1) {
      return { success: false, error: "Kolom 'Username' tidak ditemukan di sheet Users." };
    }
    if (primaryEmailColIdx === -1) {
      // Jika kolom PrimaryEmail belum ada, coba tambahkan (opsional, lebih baik disiapkan manual)
      // usersSheet.insertColumnAfter(usersSheet.getLastColumn());
      // usersSheet.getRange(1, usersSheet.getLastColumn()).setValue("PrimaryEmail");
      // return { success: false, error: "Kolom 'PrimaryEmail' baru saja dibuat. Silakan coba lagi."};
      // Untuk sekarang, kita asumsikan kolom sudah ada.
      return { success: false, error: "Kolom 'PrimaryEmail' tidak ditemukan di sheet Users. Harap tambahkan kolom tersebut." };
    }

    let userFound = false;
    let userRowIndex = -1;

    // Cek apakah email sudah digunakan oleh pengguna lain (baik di kolom Username maupun PrimaryEmail)
    for (let i = 1; i < data.length; i++) {
      const currentSheetUsername = data[i][usernameColIdx] ? String(data[i][usernameColIdx]).trim() : "";
      const currentSheetPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim() : "";

      if (currentSheetUsername.toLowerCase() !== username.toLowerCase()) { // Jangan cek email pada user yang sama
        if (currentSheetUsername.toLowerCase() === primaryEmail.toLowerCase() || currentSheetPrimaryEmail.toLowerCase() === primaryEmail.toLowerCase()) {
          return { success: false, error: `Email '${primaryEmail}' sudah digunakan oleh pengguna lain.` };
        }
      }
    }

    // Cari baris pengguna yang sesuai dan update emailnya
    for (let i = 1; i < data.length; i++) {
      if (data[i][usernameColIdx] && String(data[i][usernameColIdx]).trim().toLowerCase() === username.toLowerCase()) {
        usersSheet.getRange(i + 1, primaryEmailColIdx + 1).setValue(primaryEmail.trim());
        userFound = true;
        userRowIndex = i + 1; // Untuk log jika perlu
        break;
      }
    }

    if (!userFound) {
      return { success: false, error: `Pengguna '${username}' tidak ditemukan.` };
    }

    SpreadsheetApp.flush(); // Pastikan perubahan disimpan
    return { success: true, message: "Email berhasil disimpan.", savedEmail: primaryEmail.trim() };

  } catch (e) {
    Logger.log(`Error in saveUserPrimaryEmail (username: ${username}, email: ${primaryEmail}): ${e.toString()}`);
    return { success: false, error: `Gagal menyimpan email: ${e.message}` };
  }
}

// Di dalam code.gs.html

// Helper function to generate OTP
function generateOTP(length = 6) {
  let otp = '';
  const digits = '0123456789';
  for (let i = 0; i < length; i++) {
    otp += digits[Math.floor(Math.random() * 10)];
  }
  return otp;
}

function requestPasswordResetOTP(identifier) {
  try {
    if (!identifier || String(identifier).trim() === "") {
      return { success: false, error: "Username atau Email harus diisi." };
    }
    identifier = String(identifier).trim().toLowerCase(); // Case insensitive search

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail"); // Kolom PrimaryEmail

    if (usernameColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Konfigurasi sheet Users tidak lengkap (membutuhkan kolom Username dan PrimaryEmail)." };
    }

    let userRow = null;
    let targetEmail = null;
    let actualUsername = null;

    for (let i = 1; i < data.length; i++) {
      const sheetUsername = data[i][usernameColIdx] ? String(data[i][usernameColIdx]).trim().toLowerCase() : "";
      const sheetPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim().toLowerCase() : "";

      if (sheetUsername === identifier || sheetPrimaryEmail === identifier) {
        userRow = data[i];
        actualUsername = String(data[i][usernameColIdx]).trim(); // Username asli dari sheet
        targetEmail = String(data[i][primaryEmailColIdx]).trim(); // Email utama dari sheet
        break;
      }
    }

    if (!userRow) {
      return { success: false, error: "Username atau Email tidak terdaftar." };
    }

    if (!targetEmail) {
      return { success: false, error: `Pengguna '${actualUsername}' tidak memiliki email utama yang terdaftar untuk reset password.` };
    }

    // Validasi format email target sebelum mengirim (sebagai tindakan pencegahan)
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(targetEmail)) {
        Logger.log(`Format PrimaryEmail tidak valid untuk pengguna ${actualUsername}: ${targetEmail}`);
        return { success: false, error: `Email utama untuk pengguna '${actualUsername}' tidak valid. Hubungi administrator.` };
    }


    const otp = generateOTP(6);
    const expiryMinutes = 10; // OTP berlaku selama 10 menit
    const expiryTimestamp = new Date().getTime() + expiryMinutes * 60 * 1000;

    // Simpan OTP menggunakan PropertiesService (Script scope)
    // Kita gunakan username asli sebagai bagian dari key untuk unikasi
    const scriptProperties = PropertiesService.getScriptProperties();
    scriptProperties.setProperty(`otp_${actualUsername}`, otp);
    scriptProperties.setProperty(`otp_expiry_${actualUsername}`, expiryTimestamp.toString());
    scriptProperties.setProperty(`otp_email_${actualUsername}`, targetEmail); // Simpan email yang dikirimi OTP

    // Kirim email OTP
    const subject = "Kode OTP Reset Password Ceklok Guru";
    const body = `Halo ${actualUsername},\n\n` +
                 `Kode OTP Anda untuk reset password adalah: ${otp}\n\n` +
                 `Kode ini akan kedaluwarsa dalam ${expiryMinutes} menit.\n` +
                 `Jika Anda tidak meminta reset password, abaikan email ini.\n\n` +
                 `Terima kasih,\nAplikasi Ceklok Guru`;

    try {
      MailApp.sendEmail(targetEmail, subject, body);
      Logger.log(`OTP dikirim ke ${targetEmail} untuk user ${actualUsername}`);
      // Kembalikan username asli, karena identifier bisa jadi email
      return { success: true, message: `OTP telah dikirim ke email ${maskEmail(targetEmail)}. Silakan periksa inbox atau spam Anda.`, username: actualUsername };
    } catch (e) {
      Logger.log(`Gagal mengirim OTP ke ${targetEmail} untuk user ${actualUsername}: ${e.toString()}`);
      return { success: false, error: `Gagal mengirim OTP ke email Anda. Error: ${e.message}` };
    }

  } catch (e) {
    Logger.log(`Error di requestPasswordResetOTP (identifier: ${identifier}): ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server: ${e.message}` };
  }
}

// Helper function to mask email for display
function maskEmail(email) {
  if (!email || email.indexOf('@') === -1) return email;
  const [localPart, domain] = email.split('@');
  const [domainName, domainTld] = domain.split('.');
  
  let maskedLocalPart;
  if (localPart.length <= 3) {
    maskedLocalPart = localPart[0] + '*'.repeat(localPart.length - 1);
  } else {
    maskedLocalPart = localPart.substring(0, 2) + '*'.repeat(localPart.length - 4) + localPart.substring(localPart.length - 2);
  }
  return `${maskedLocalPart}@${domainName[0]}***.${domainTld}`;
}



// Tambahkan fungsi ini di dalam code.gs.html

function verifyOTPAndResetPassword(username, otpInput, newPassword) {
  try {
    if (!username || !otpInput || !newPassword) {
      return { success: false, error: "Informasi tidak lengkap (Username, OTP, Password Baru wajib diisi)." };
    }
    
    username = String(username).trim(); // Pastikan username adalah username asli, bukan email jika beda
    otpInput = String(otpInput).trim();
    newPassword = String(newPassword); // Password bisa mengandung spasi, jadi tidak di-trim kecuali memang diinginkan

    if (newPassword.length < 4) { // Validasi panjang password baru di server
        return { success: false, error: "Password baru minimal 4 karakter." };
    }

    const scriptProperties = PropertiesService.getScriptProperties();
    const storedOtp = scriptProperties.getProperty(`otp_${username}`);
    const storedExpiry = scriptProperties.getProperty(`otp_expiry_${username}`);

    if (!storedOtp || !storedExpiry) {
      return { success: false, error: "OTP tidak ditemukan atau sudah kedaluwarsa. Silakan minta OTP baru." };
    }

    const expiryTimestamp = parseInt(storedExpiry, 10);
    if (isNaN(expiryTimestamp) || new Date().getTime() > expiryTimestamp) {
      // Hapus OTP yang sudah kedaluwarsa
      scriptProperties.deleteProperty(`otp_${username}`);
      scriptProperties.deleteProperty(`otp_expiry_${username}`);
      scriptProperties.deleteProperty(`otp_email_${username}`); // Hapus juga email terkait OTP
      return { success: false, error: "OTP sudah kedaluwarsa. Silakan minta OTP baru." };
    }

    if (storedOtp !== otpInput) {
      return { success: false, error: "Kode OTP salah." };
    }

    // OTP valid dan belum kedaluwarsa, lanjutkan reset password
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) {
      return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };
    }

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const passwordColIdx = headers.indexOf("password");

    if (usernameColIdx === -1 || passwordColIdx === -1) {
      return { success: false, error: "Struktur kolom di sheet Users tidak lengkap (Username/Password)." };
    }

    let userFound = false;
    for (let i = 1; i < data.length; i++) {
      if (data[i][usernameColIdx] && String(data[i][usernameColIdx]).trim().toLowerCase() === username.toLowerCase()) {
        usersSheet.getRange(i + 1, passwordColIdx + 1).setValue(newPassword);
        userFound = true;
        break;
      }
    }

    if (!userFound) {
      // Seharusnya tidak terjadi jika username valid dari proses request OTP
      return { success: false, error: `Pengguna '${username}' tidak ditemukan untuk update password.` };
    }

    // Hapus OTP setelah berhasil digunakan
    scriptProperties.deleteProperty(`otp_${username}`);
    scriptProperties.deleteProperty(`otp_expiry_${username}`);
    scriptProperties.deleteProperty(`otp_email_${username}`);
    
    SpreadsheetApp.flush();
    Logger.log(`Password berhasil direset untuk pengguna: ${username}`);
    return { success: true, message: "Password Anda telah berhasil direset. Silakan login dengan password baru Anda." };

  } catch (e) {
    Logger.log(`Error di verifyOTPAndResetPassword (username: ${username}): ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server saat mereset password: ${e.message}` };
  }
}


// Di dalam code.gs.html

// (Pastikan fungsi generateOTP sudah ada dari implementasi lupa password)
// function generateOTP(length = 6) { ... }

const CHANGE_EMAIL_OTP_EXPIRY_MINUTES = 10; // Durasi OTP ganti email

function requestChangePrimaryEmailOTP(username, newProposedEmail) {
  try {
    if (!username || !newProposedEmail) {
      return { success: false, error: "Informasi pengguna atau email baru tidak lengkap." };
    }

    newProposedEmail = String(newProposedEmail).trim().toLowerCase();
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(newProposedEmail)) {
      return { success: false, error: "Format email baru tidak valid." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Struktur kolom Users tidak lengkap (Username/PrimaryEmail)." };
    }

    let currentUserRow = null;
    let oldPrimaryEmail = null;

    for (let i = 1; i < data.length; i++) {
      const sheetUsername = data[i][usernameColIdx] ? String(data[i][usernameColIdx]).trim().toLowerCase() : "";
      
      // Cek apakah email baru sudah digunakan oleh pengguna LAIN
      if (sheetUsername !== username.toLowerCase()) {
          const otherUserPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim().toLowerCase() : "";
          const otherUserUsernameAsEmail = sheetUsername.includes('@') ? sheetUsername : null;

          if (otherUserPrimaryEmail === newProposedEmail || (otherUserUsernameAsEmail && otherUserUsernameAsEmail === newProposedEmail) ) {
              return { success: false, error: `Email baru '${newProposedEmail}' sudah digunakan oleh pengguna lain.` };
          }
      }
      
      if (sheetUsername === username.toLowerCase()) {
        currentUserRow = data[i];
        oldPrimaryEmail = currentUserRow[primaryEmailColIdx] ? String(currentUserRow[primaryEmailColIdx]).trim() : null;
        // break; // Lanjutkan loop untuk cek duplikat email baru oleh pengguna lain
      }
    }

    if (!currentUserRow) {
      return { success: false, error: "Pengguna tidak ditemukan." };
    }
    if (!oldPrimaryEmail) {
      return { success: false, error: "Anda belum memiliki email utama terdaftar untuk dikirimi OTP." };
    }
     if (oldPrimaryEmail.toLowerCase() === newProposedEmail) {
      return { success: false, error: "Email baru tidak boleh sama dengan email lama Anda." };
    }


    const otp = generateOTP(6);
    const expiryTimestamp = new Date().getTime() + CHANGE_EMAIL_OTP_EXPIRY_MINUTES * 60 * 1000;

    const scriptProperties = PropertiesService.getScriptProperties();
    // Kunci OTP berbeda untuk ganti email
    scriptProperties.setProperty(`changeEmailOtp_${username}`, otp);
    scriptProperties.setProperty(`changeEmailOtpExpiry_${username}`, expiryTimestamp.toString());
    scriptProperties.setProperty(`changeEmailNewEmail_${username}`, newProposedEmail); // Simpan email baru yang diusulkan

    const subject = "Kode Verifikasi Perubahan Email Ceklok Guru";
    const body = `Halo ${username},\n\n` +
                 `Kode verifikasi Anda untuk mengubah alamat email adalah: ${otp}\n\n` +
                 `Kode ini akan kedaluwarsa dalam ${CHANGE_EMAIL_OTP_EXPIRY_MINUTES} menit.\n` +
                 `Jika Anda tidak meminta perubahan ini, abaikan email ini.\n\n` +
                 `Terima kasih,\nAplikasi Ceklok Guru`;

    try {
      MailApp.sendEmail(oldPrimaryEmail, subject, body);
      Logger.log(`OTP Perubahan Email dikirim ke ${oldPrimaryEmail} untuk user ${username} (usulan baru: ${newProposedEmail})`);
      return { success: true, message: `Kode verifikasi telah dikirim ke email lama Anda (${maskEmail(oldPrimaryEmail)}).`, newEmailPreview: newProposedEmail, oldEmailForDisplay: oldPrimaryEmail };
    } catch (e) {
      Logger.log(`Gagal mengirim OTP Perubahan Email ke ${oldPrimaryEmail}: ${e.toString()}`);
      return { success: false, error: `Gagal mengirim kode verifikasi. Error: ${e.message}` };
    }

  } catch (e) {
    Logger.log(`Error di requestChangePrimaryEmailOTP: ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server: ${e.message}` };
  }
}


function verifyAndChangePrimaryEmail(username, otpInput, clientProposedNewEmail) {
  try {
    if (!username || !otpInput || !clientProposedNewEmail) {
      return { success: false, error: "Informasi tidak lengkap (Username, OTP, Email Baru)." };
    }
    username = String(username).trim().toLowerCase();
    otpInput = String(otpInput).trim();
    clientProposedNewEmail = String(clientProposedNewEmail).trim().toLowerCase();

    const scriptProperties = PropertiesService.getScriptProperties();
    const storedOtp = scriptProperties.getProperty(`changeEmailOtp_${username}`);
    const storedExpiry = scriptProperties.getProperty(`changeEmailOtpExpiry_${username}`);
    const storedNewEmail = scriptProperties.getProperty(`changeEmailNewEmail_${username}`);

    if (!storedOtp || !storedExpiry || !storedNewEmail) {
      return { success: false, error: "Sesi perubahan email tidak ditemukan atau OTP kedaluwarsa. Silakan ulangi." };
    }

    const expiryTimestamp = parseInt(storedExpiry, 10);
    if (isNaN(expiryTimestamp) || new Date().getTime() > expiryTimestamp) {
      scriptProperties.deleteProperty(`changeEmailOtp_${username}`);
      scriptProperties.deleteProperty(`changeEmailOtpExpiry_${username}`);
      scriptProperties.deleteProperty(`changeEmailNewEmail_${username}`);
      return { success: false, error: "Kode verifikasi sudah kedaluwarsa. Silakan minta kode baru." };
    }

    if (storedOtp !== otpInput) {
      return { success: false, error: "Kode verifikasi salah." };
    }

    if (storedNewEmail.toLowerCase() !== clientProposedNewEmail) {
        Logger.log(`Peringatan keamanan: clientProposedNewEmail (${clientProposedNewEmail}) tidak cocok dengan storedNewEmail (${storedNewEmail}) untuk user ${username}`);
        return { success: false, error: "Proses perubahan email tidak valid. Silakan ulangi." };
    }
    
    // OTP valid, email baru cocok, lanjutkan ganti email di sheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Struktur kolom Users tidak lengkap." };
    }

    // Cek lagi apakah email baru sudah digunakan oleh pengguna LAIN (double check, antisipasi race condition kecil)
    for (let i = 1; i < data.length; i++) {
        const sheetUsername = data[i][usernameColIdx] ? String(data[i][usernameColIdx]).trim().toLowerCase() : "";
        if (sheetUsername !== username) { // Hanya cek untuk pengguna lain
            const otherUserPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim().toLowerCase() : "";
            const otherUserUsernameAsEmail = sheetUsername.includes('@') ? sheetUsername : null;
            if (otherUserPrimaryEmail === clientProposedNewEmail || (otherUserUsernameAsEmail && otherUserUsernameAsEmail === clientProposedNewEmail)) {
                return { success: false, error: `Email baru '${clientProposedNewEmail}' sudah digunakan pengguna lain (cek terakhir).` };
            }
        }
    }


    let userFoundAndUpdate = false;
    for (let i = 1; i < data.length; i++) {
      if (data[i][usernameColIdx] && String(data[i][usernameColIdx]).trim().toLowerCase() === username) {
        usersSheet.getRange(i + 1, primaryEmailColIdx + 1).setValue(clientProposedNewEmail);
        userFoundAndUpdate = true;
        break;
      }
    }

    if (!userFoundAndUpdate) {
      return { success: false, error: `Pengguna '${username}' tidak ditemukan untuk update email.` };
    }

    // Hapus properti OTP setelah berhasil digunakan
    scriptProperties.deleteProperty(`changeEmailOtp_${username}`);
    scriptProperties.deleteProperty(`changeEmailOtpExpiry_${username}`);
    scriptProperties.deleteProperty(`changeEmailNewEmail_${username}`);
    
    SpreadsheetApp.flush();
    Logger.log(`PrimaryEmail berhasil diubah untuk ${username} menjadi ${clientProposedNewEmail}`);
    return { success: true, message: "Alamat email utama Anda telah berhasil diperbarui.", updatedEmail: clientProposedNewEmail };

  } catch (e) {
    Logger.log(`Error di verifyAndChangePrimaryEmail: ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server: ${e.message}` };
  }
}



// --- Fungsi untuk Verifikasi Email Utama Baru dengan OTP ---

/**
 * Meminta OTP untuk verifikasi email utama baru.
 * Mengirim OTP ke email yang akan diverifikasi.
 * @param {string} username Username pengguna yang meminta.
 * @param {string} emailToVerify Email yang ingin diatur sebagai email utama dan diverifikasi.
 * @return {object} Hasil operasi {success: boolean, message/error: string, emailSentTo?: string}.
 */
function requestPrimaryEmailVerificationOTP(username, emailToVerify) {
  try {
    if (!username || !emailToVerify) {
      return { success: false, error: "Username dan Email tidak boleh kosong." };
    }
    emailToVerify = String(emailToVerify).trim().toLowerCase();
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(emailToVerify)) {
      return { success: false, error: "Format email tidak valid." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Struktur kolom Users tidak lengkap (Username/PrimaryEmail)." };
    }

    // Cek apakah emailToVerify sudah digunakan oleh PENGGUNA LAIN
    for (let i = 1; i < data.length; i++) {
      const sheetUsername = data[i][usernameColIdx] ? String(data[i][usernameColIdx]).trim().toLowerCase() : "";
      if (sheetUsername !== username.toLowerCase()) { // Periksa hanya untuk pengguna lain
        const otherUserPrimaryEmail = data[i][primaryEmailColIdx] ? String(data[i][primaryEmailColIdx]).trim().toLowerCase() : "";
        // Juga cek apakah email tersebut adalah username pengguna lain (jika username bisa berupa email)
        const otherUserUsernameAsEmail = sheetUsername.includes('@') ? sheetUsername : null;
        if (otherUserPrimaryEmail === emailToVerify || (otherUserUsernameAsEmail && otherUserUsernameAsEmail === emailToVerify)) {
          return { success: false, error: `Email '${emailToVerify}' sudah terdaftar untuk pengguna lain.` };
        }
      }
    }
    
    // Cek apakah pengguna yang meminta sudah punya primary email yang sama
    let userRow = null;
    for (let i = 1; i < data.length; i++) {
        if (data[i][usernameColIdx] && String(data[i][usernameColIdx]).trim().toLowerCase() === username.toLowerCase()) {
            userRow = data[i];
            break;
        }
    }
    if(userRow){
        const currentUserPrimaryEmail = userRow[primaryEmailColIdx] ? String(userRow[primaryEmailColIdx]).trim().toLowerCase() : "";
        if(currentUserPrimaryEmail === emailToVerify){
            // Jika email yang diinput sama dengan email utama yang sudah terverifikasi, tidak perlu OTP lagi.
            // Namun, karena modal ini muncul jika !loggedInUser.primaryEmail, kondisi ini seharusnya jarang terjadi
            // kecuali jika ada proses yang tidak sinkron. Anggap saja ini sebagai validasi tambahan.
            return { success: false, error: `Email '${emailToVerify}' sudah menjadi email utama Anda.` };
        }
    } else {
        return { success: false, error: `Pengguna '${username}' tidak ditemukan.` }; // Seharusnya tidak terjadi
    }


    const otp = generateOTP(6); // Asumsi fungsi generateOTP sudah ada
    const expiryMinutes = PRIMARY_EMAIL_OTP_EXPIRY_MINUTES || 10;
    const expiryTimestamp = new Date().getTime() + expiryMinutes * 60 * 1000;

    const scriptProperties = PropertiesService.getScriptProperties();
    const otpKeyPrefix = "primaryEmailSetupOtp_";
    scriptProperties.setProperty(`${otpKeyPrefix}${username}`, otp);
    scriptProperties.setProperty(`${otpKeyPrefix}expiry_${username}`, expiryTimestamp.toString());
    scriptProperties.setProperty(`${otpKeyPrefix}email_${username}`, emailToVerify); // Simpan email yang diverifikasi

    const subject = "Kode Verifikasi Email Utama Ceklok Guru";
    const body = `Halo ${username},\n\n` +
                 `Kode verifikasi Anda untuk mengatur email utama adalah: ${otp}\n\n` +
                 `Email yang akan diverifikasi: ${emailToVerify}\n`+
                 `Kode ini akan kedaluwarsa dalam ${expiryMinutes} menit.\n` +
                 `Jika Anda tidak meminta ini, abaikan email ini.\n\n` +
                 `Terima kasih,\nAplikasi Ceklok Guru`;

    try {
      MailApp.sendEmail(emailToVerify, subject, body);
      Logger.log(`OTP Verifikasi Email Utama dikirim ke ${emailToVerify} untuk user ${username}`);
      return { success: true, message: `OTP telah dikirim ke ${maskEmail(emailToVerify)}. Silakan periksa inbox atau spam Anda.`, emailSentTo: emailToVerify };
    } catch (e) {
      Logger.log(`Gagal mengirim OTP Verifikasi Email Utama ke ${emailToVerify} (user ${username}): ${e.toString()}`);
      return { success: false, error: `Gagal mengirim OTP. Error: ${e.message}` };
    }

  } catch (e) {
    Logger.log(`Error di requestPrimaryEmailVerificationOTP (user: ${username}, email: ${emailToVerify}): ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server: ${e.message}` };
  }
}

/**
 * Memverifikasi OTP dan menyimpan email utama jika OTP valid.
 * @param {string} username Username pengguna.
 * @param {string} otpInput OTP yang dimasukkan pengguna.
 * @param {string} emailToSave Email yang akan disimpan setelah verifikasi.
 * @return {object} Hasil operasi {success: boolean, message/error: string, savedEmail?: string}.
 */
function verifyPrimaryEmailOTPAndSave(username, otpInput, emailToSave) {
  try {
    if (!username || !otpInput || !emailToSave) {
      return { success: false, error: "Informasi verifikasi tidak lengkap." };
    }
    username = String(username).trim().toLowerCase();
    otpInput = String(otpInput).trim();
    emailToSave = String(emailToSave).trim().toLowerCase();

    const scriptProperties = PropertiesService.getScriptProperties();
    const otpKeyPrefix = "primaryEmailSetupOtp_";
    const storedOtp = scriptProperties.getProperty(`${otpKeyPrefix}${username}`);
    const storedExpiry = scriptProperties.getProperty(`${otpKeyPrefix}expiry_${username}`);
    const storedEmailForOtp = scriptProperties.getProperty(`${otpKeyPrefix}email_${username}`);

    if (!storedOtp || !storedExpiry || !storedEmailForOtp) {
      return { success: false, error: "Sesi verifikasi OTP tidak ditemukan atau sudah kedaluwarsa. Silakan minta OTP baru." };
    }

    const expiryTimestamp = parseInt(storedExpiry, 10);
    if (isNaN(expiryTimestamp) || new Date().getTime() > expiryTimestamp) {
      scriptProperties.deleteProperty(`${otpKeyPrefix}${username}`);
      scriptProperties.deleteProperty(`${otpKeyPrefix}expiry_${username}`);
      scriptProperties.deleteProperty(`${otpKeyPrefix}email_${username}`);
      return { success: false, error: "OTP sudah kedaluwarsa. Silakan minta OTP baru." };
    }

    if (storedOtp !== otpInput) {
      return { success: false, error: "Kode OTP salah." };
    }

    if (storedEmailForOtp.toLowerCase() !== emailToSave) {
      Logger.log(`Peringatan keamanan: emailToSave (${emailToSave}) tidak cocok dengan storedEmailForOtp (${storedEmailForOtp}) untuk user ${username} saat verifikasi primary email.`);
      return { success: false, error: "Proses verifikasi email tidak valid. Silakan ulangi." };
    }
    
    // OTP valid, email cocok, lanjutkan simpan email di sheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) return { success: false, error: `Sheet '${USERS_SHEET_NAME}' tidak ditemukan.` };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim().toLowerCase());
    const usernameColIdx = headers.indexOf("username");
    const primaryEmailColIdx = headers.indexOf("primaryemail");

    if (usernameColIdx === -1 || primaryEmailColIdx === -1) {
      return { success: false, error: "Struktur kolom Users tidak lengkap." };
    }

    let userFoundAndUpdate = false;
    for (let i = 1; i < data.length; i++) {
      if (data[i][usernameColIdx] && String(data[i][usernameColIdx]).trim().toLowerCase() === username) {
        usersSheet.getRange(i + 1, primaryEmailColIdx + 1).setValue(emailToSave);
        userFoundAndUpdate = true;
        break;
      }
    }

    if (!userFoundAndUpdate) {
      return { success: false, error: `Pengguna '${username}' tidak ditemukan untuk update email.` }; // Seharusnya tidak terjadi
    }

    scriptProperties.deleteProperty(`${otpKeyPrefix}${username}`);
    scriptProperties.deleteProperty(`${otpKeyPrefix}expiry_${username}`);
    scriptProperties.deleteProperty(`${otpKeyPrefix}email_${username}`);
    
    SpreadsheetApp.flush();
    Logger.log(`Email utama berhasil diverifikasi dan disimpan untuk ${username} menjadi ${emailToSave}`);
    return { success: true, message: "Email utama Anda telah berhasil diverifikasi dan disimpan.", savedEmail: emailToSave };

  } catch (e) {
    Logger.log(`Error di verifyPrimaryEmailOTPAndSave (user: ${username}, email: ${emailToSave}): ${e.toString()}`);
    return { success: false, error: `Terjadi kesalahan server: ${e.message}` };
  }
}

// Pastikan fungsi generateOTP dan maskEmail sudah ada:
/*
function generateOTP(length = 6) {
  let otp = '';
  const digits = '0123456789';
  for (let i = 0; i < length; i++) {
    otp += digits[Math.floor(Math.random() * 10)];
  }
  return otp;
}

function maskEmail(email) {
  if (!email || email.indexOf('@') === -1) return email;
  const [localPart, domain] = email.split('@');
  const [domainName, domainTld] = domain.split('.');
  
  let maskedLocalPart;
  if (localPart.length <= 3) {
    maskedLocalPart = localPart[0] + '*'.repeat(localPart.length - 1);
  } else {
    maskedLocalPart = localPart.substring(0, 2) + '*'.repeat(localPart.length - 4) + localPart.substring(localPart.length - 2);
  }
  return `${maskedLocalPart}@${domainName[0]}***.${domainTld}`;
}
*/



// ============== FUNGSI BARU UNTUK NOTIFIKASI PENGINGAT ABSENSI ==============

/**
 * Fungsi utama yang akan dipicu oleh trigger harian
 * untuk memeriksa dan mengirim notifikasi pengingat absensi.
 * Sesuai permintaan baru, fungsi ini hanya akan memanggil notifikasi ringkasan
 * jika tanggal saat ini berada dalam 7 hari terakhir di bulan berjalan.
 */
function checkAndSendAttendanceReminders() {
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Normalisasi tanggal hari ini ke awal hari

  const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
  const dateOfMonth = today.getDate();

  // Hanya jalankan notifikasi jika berada dalam 7 hari terakhir bulan ini.
  // Contoh: Juni (30 hari), notifikasi berjalan dari tanggal 23 sampai 30.
  // 30 - 7 = 23. Jadi notifikasi aktif jika tanggal >= 23.
  if (dateOfMonth >= (lastDayOfMonth - 7)) {
    // Panggil fungsi baru untuk mengirim ringkasan bulanan.
    sendMonthlySummaryNotification(today);
  } else {
    // Di luar periode 7 hari terakhir, tidak ada notifikasi harian yang dikirim
    // sesuai dengan permintaan pengguna.
    Logger.log("Di luar periode notifikasi ringkasan akhir bulan, tidak ada email yang dikirim.");
  }
}

/**
 * MODIFIED FUNCTION V3 (Fix Logging Period)
 * Mengirimkan ringkasan kehadiran bulanan atau pengingat kekurangan kepada setiap guru aktif.
 * Fungsi ini dipanggil jika tanggal saat ini berada dalam 7 hari terakhir bulan berjalan.
 *
 * LOGIKA BARU:
 * 1. Jika kehadiran guru sudah 100%, kirim email ringkasan lengkap SATU KALI SAJA sebulan.
 * 2. Jika kehadiran < 100%, kirim email pengingat harian yang HANYA berisi jumlah Alpa dan Ceklok Tidak Lengkap.
 * 3. Menggunakan nama bulan dalam Bahasa Indonesia.
 * 4. Memperbaiki format periode yang dicatat di log untuk notifikasi 100%.
 *
 * @param {Date} todayObj Objek Date untuk hari ini.
 */
function sendMonthlySummaryNotification(todayObj) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);

  if (!usersSheet) {
    Logger.log("Peringatan: Sheet Users tidak ditemukan. Proses pengingat ringkasan dibatalkan.");
    return;
  }

  const usersData = usersSheet.getDataRange().getValues();
  const userHeaders = usersData[0].map(h => String(h).trim().toLowerCase());
  const idxUserTeacherName = userHeaders.indexOf("nama_guru_asli");
  const idxUserPrimaryEmail = userHeaders.indexOf("primaryemail");
  const idxUserRole = userHeaders.indexOf("role");

  if ([idxUserTeacherName, idxUserPrimaryEmail, idxUserRole].includes(-1)) {
    Logger.log("Error: Kolom penting (nama_guru_asli, primaryemail, role) di sheet Users tidak ditemukan. Proses pengingat dibatalkan.");
    return;
  }

  const activeTeachers = [];
  for (let i = 1; i < usersData.length; i++) {
    const teacherName = usersData[i][idxUserTeacherName] ? String(usersData[i][idxUserTeacherName]).trim() : "";
    const primaryEmail = usersData[i][idxUserPrimaryEmail] ? String(usersData[i][idxUserPrimaryEmail]).trim() : "";
    const role = usersData[i][idxUserRole] ? String(usersData[i][idxUserRole]).trim().toLowerCase() : "";

    if (role === "user" && teacherName && primaryEmail && helper_isValidEmailFormat(primaryEmail)) {
      activeTeachers.push({ name: teacherName, email: primaryEmail });
    }
  }

  if (activeTeachers.length === 0) {
    Logger.log("Tidak ada guru aktif dengan email valid untuk dikirimi ringkasan.");
    return;
  }

  const monthYearStr = Utilities.formatDate(todayObj, Session.getScriptTimeZone(), "MM/yyyy");
  
  const monthNamesIndonesian = ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"];
  const monthIndex = todayObj.getMonth();
  const monthName = monthNamesIndonesian[monthIndex];
  
  const year = todayObj.getFullYear();
  const reminderLogSheet = ensureSheet(REMINDER_LOG_SHEET_NAME, [
    "Nama_Guru", "Target_Periode", "Tipe_Notifikasi", "Tanggal_Kirim", "Detail"
  ]);
  const todayStr = Utilities.formatDate(todayObj, Session.getScriptTimeZone(), "dd/MM/yyyy");

  activeTeachers.forEach(teacher => {
    Logger.log(`Memproses notifikasi untuk ${teacher.name} untuk bulan ${monthYearStr}`);
    const summaryResult = getTeacherMonthlySummary(teacher.name, monthYearStr);

    if (summaryResult.success) {
      const summary = summaryResult.summary;

      if (summary.attendancePercentage === 100) {
        const notifType100Percent = `summary_100_percent_sent`;
        if (!helper_hasSentNotificationInMonth(reminderLogSheet, teacher.name, monthYearStr, notifType100Percent)) {
          Logger.log(`Kehadiran ${teacher.name} sudah 100%. Mengirim email ringkasan lengkap (satu kali).`);
          
          const subject = `Selamat! Kehadiran Anda Sudah 100% Untuk Bulan ${monthName} ${year}`;
          let body = `Yth. ${teacher.name},\n\n`;
          body += `Selamat! Pengisian data kehadiran Anda untuk bulan ${monthName} ${year} telah lengkap (100%).\n\n`;
          body += `Berikut adalah ringkasan akhir Anda:\n`;
          body += `-------------------------------------------------\n`;
          body += `Total Hari Kerja: ${summary.totalWorkingDaysInMonth} hari\n`;
          body += `Ceklok Terisi Lengkap: ${summary.completedChecklok} hari\n`;
          body += `   - Hadir (Jam Lengkap): ${summary.present} hari\n`;
          body += `   - Hari Libur Sekolah (Input Guru): ${summary.schoolHoliday} hari\n`;
          body += `   - Alasan Lain (Valid): ${summary.otherValidReason} hari\n`;
          body += `Alpa: 0 hari\n`;
          body += `Ceklok Tidak Lengkap: 0 hari\n`;
          body += `-------------------------------------------------\n\n`;
          body += `Terima kasih atas kedisiplinan Anda.\n\n`;
          body += `${EMAIL_SENDER_NAME}`;
          
          try {
            MailApp.sendEmail({ to: teacher.email, subject: subject, body: body, name: EMAIL_SENDER_NAME });
            // --- PERBAIKAN LOGGING DI SINI ---
            // Pastikan mengirim monthYearStr ("MM/yyyy") sebagai periode log
            helper_logSentNotification(reminderLogSheet, teacher.name, monthYearStr, notifType100Percent, "Sent on " + todayStr);
            Logger.log(`Email ringkasan 100% berhasil dikirim ke ${teacher.name} (${teacher.email})`);
          } catch (e) {
            Logger.log(`Gagal mengirim email ringkasan 100% ke ${teacher.email}: ${e.toString()}`);
          }
        } else {
          Logger.log(`Notifikasi 100% untuk ${teacher.name} bulan ${monthYearStr} sudah pernah dikirim. Tidak mengirim lagi.`);
        }

      } else {
        const notifTypeReminder = `daily_reminder_incomplete`;
        // Untuk pengingat harian, kita menggunakan todayStr sebagai periode agar unik setiap hari
        if (!helper_hasSentNotificationToday(reminderLogSheet, teacher.name, todayStr, notifTypeReminder)) {
           Logger.log(`Kehadiran ${teacher.name} masih < 100%. Mengirim email pengingat harian.`);

           const subject = `Pengingat: Mohon Lengkapi Kehadiran Bulan ${monthName} ${year}`;
           let body = `Yth. ${teacher.name},\n\n`;
           body += `Ini adalah pemberitahuan harian Anda selama minggu terakhir bulan ini.\n`;
           body += `Sistem kami mencatat bahwa data kehadiran Anda untuk bulan ${monthName} ${year} masih belum lengkap.\n\n`;
           body += `Berikut adalah data yang perlu menjadi perhatian (data per tanggal ${todayStr}):\n`;
           body += `-------------------------------------------------\n`;
           body += `Jumlah Alpa (Data Kosong): ${summary.absent} hari\n`;
           body += `Jumlah Ceklok Tidak Lengkap (Hanya 1 jam terisi): ${summary.incomplete} hari\n`;
           body += `-------------------------------------------------\n\n`;
           body += `Mohon untuk segera melengkapi data Anda melalui aplikasi Ceklok sebelum akhir bulan.\n\n`;
           body += `Terima kasih.\n${EMAIL_SENDER_NAME}`;

           try {
             MailApp.sendEmail({ to: teacher.email, subject: subject, body: body, name: EMAIL_SENDER_NAME });
             helper_logSentNotification(reminderLogSheet, teacher.name, todayStr, notifTypeReminder, `Absent: ${summary.absent}, Incomplete: ${summary.incomplete}`);
             Logger.log(`Email pengingat harian berhasil dikirim ke ${teacher.name} (${teacher.email})`);
           } catch(e) {
             Logger.log(`Gagal mengirim email pengingat harian ke ${teacher.email}: ${e.toString()}`);
           }
        } else {
            Logger.log(`Pengingat harian untuk ${teacher.name} sudah dikirim hari ini (${todayStr}). Tidak mengirim lagi.`);
        }
      }
    } else {
      Logger.log(`Gagal mendapatkan data ringkasan untuk ${teacher.name}: ${summaryResult.error}`);
    }
  });
}

/**
 * Helper: Mencatat notifikasi yang sudah dikirim ke sheet Reminder_Log.
 * VERSI FINAL: Memaksa format periode "MM/YYYY" menjadi teks dengan apostrof
 * untuk mencegah konversi otomatis oleh Google Sheet.
 */
function helper_logSentNotification(reminderLogSheet, teacherName, periodOrDateStr, notifType, detail) {
  if (reminderLogSheet) {
    let periodToLog = periodOrDateStr;

    // Cek apakah periode yang akan dicatat memiliki format "MM/YYYY"
    if (/^\d{2}\/\d{4}$/.test(periodOrDateStr)) {
      // **INILAH KUNCI PERBAIKANNYA**
      // Tambahkan apostrof di depan untuk memaksa Google Sheet menyimpannya sebagai teks.
      periodToLog = "'" + periodOrDateStr;
      Logger.log(`DEBUG (helper_logSentNotification): Format periode MM/YYYY terdeteksi. Menyimpan ke log sebagai teks: ${periodToLog}`);
    }

    // Tulis baris baru ke log dengan nilai yang sudah diformat paksa
    reminderLogSheet.appendRow([teacherName, periodToLog, notifType, new Date(), detail || ""]);
  }
}

/**
 * Helper: Memeriksa apakah notifikasi untuk guru, tanggal target, dan tipe tertentu sudah dikirim HARI INI.
 */
function helper_hasSentNotificationToday(reminderLogSheet, teacherName, targetDateStr, notifType) {
  if (!reminderLogSheet) return false;
  const todayLog = new Date();
  todayLog.setHours(0,0,0,0);
  const logData = reminderLogSheet.getDataRange().getValues();

  for (let i = logData.length - 1; i >= 1; i--) {
    const row = logData[i];
    const logTeacher = String(row[0]).trim();
    const logTargetPeriod = String(row[1]).trim();
    const logNotifType = String(row[2]).trim();
    const logSentTimestamp = row[3];
    
    let logSentDate = null;
    if (logSentTimestamp instanceof Date) { logSentDate = new Date(logSentTimestamp); }
    else if (typeof logSentTimestamp === 'string' && logSentTimestamp) { try { logSentDate = new Date(logSentTimestamp); } catch(e) {} }
    else if (typeof logSentTimestamp === 'number') { logSentDate = new Date(logSentTimestamp); }

    if(logSentDate) logSentDate.setHours(0,0,0,0);

    if (logTeacher === teacherName && logTargetPeriod === targetDateStr && logNotifType === notifType && logSentDate && logSentDate.getTime() === todayLog.getTime()) {
      return true; 
    }
  }
  return false;
}

/**
 * Helper: Memeriksa apakah notifikasi untuk guru, periode bulan, dan tipe tertentu sudah pernah dikirim.
 * VERSI DEBUG: Menambahkan logging untuk melacak proses pengecekan.
 */
function helper_hasSentNotificationInMonth(reminderLogSheet, teacherName, monthYearStr, notifType) {
  if (!reminderLogSheet) {
    Logger.log(`DEBUG: helper_hasSentNotificationInMonth: Sheet 'Reminder_Log' tidak ditemukan.`);
    return false;
  }
  const logData = reminderLogSheet.getDataRange().getValues();
  
  // Log nilai yang sedang kita cari untuk debugging
  Logger.log(`DEBUG: Mencari log untuk: Nama='${teacherName}', Periode='${monthYearStr}', Tipe='${notifType}'`);

  for (let i = 1; i < logData.length; i++) {
    const row = logData[i];
    const logTeacher = String(row[0]).trim();
    const logTargetPeriod = String(row[1]).trim();
    const logNotifType = String(row[2]).trim();

    // Hanya tampilkan log dari baris yang relevan dengan guru yang diperiksa untuk mengurangi noise
    if (logTeacher === teacherName) {
       Logger.log(`DEBUG: Memeriksa baris ${i + 1}: Nama='${logTeacher}', Periode='${logTargetPeriod}', Tipe='${logNotifType}'`);
    }
    
    // Proses perbandingan data
    if (logTeacher === teacherName && logTargetPeriod === monthYearStr && logNotifType === notifType) {
      Logger.log(`--> DEBUG: COCOK! Ditemukan di baris ${i + 1}. Notifikasi akan dilewati (SKIP).`);
      return true; // Ditemukan, notifikasi tidak akan dikirim lagi.
    }
  }
  
  Logger.log(`--> DEBUG: TIDAK COCOK. Tidak ada log yang sesuai untuk ${teacherName} periode ${monthYearStr}. Notifikasi kemungkinan akan dikirim.`);
  return false; // Tidak ditemukan, notifikasi akan dikirim.
}

/**
 * Helper: Memeriksa format email dasar.
 * @param {string} email Alamat email.
 * @return {boolean} True jika format valid.
 */
function helper_isValidEmailFormat(email) {
  if (!email) return false;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(String(email).toLowerCase());
}

/**
 * Helper: Mendapatkan map tanggal libur dari sheet Kalender Pendidikan.
 * Key: "dd/MM/yyyy", Value: Keterangan Libur.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} kalenderSheet Sheet Kalender Pendidikan.
 * @return {object} Objek map tanggal libur.
 */
function helper_getLiburMap(kalenderSheet) {
  const liburMap = {};
  if (kalenderSheet && kalenderSheet.getLastRow() > 1) {
    const kalenderData = kalenderSheet.getRange(2, 1, kalenderSheet.getLastRow() - 1, 2).getDisplayValues();
    kalenderData.forEach(row => {
      const tglText = String(row[0]).trim();
      if (tglText && /^\d{2}\/\d{2}\/\d{4}$/.test(tglText)) { // Format dd/MM/yyyy
        liburMap[tglText] = String(row[1]).trim() || "Hari Libur";
      }
    });
  }
  return liburMap;
}

/**
 * Helper: Memeriksa apakah suatu tanggal adalah hari kerja.
 * @param {Date} dateObj Objek Date yang akan diperiksa.
 * @param {object} liburMap Map tanggal libur.
 * @param {string} ketLiburManualDiSheetCeklok Keterangan libur manual dari sheet Ceklok_Manual untuk tanggal tersebut.
 * @return {boolean} True jika hari kerja.
 */
function helper_isWorkingDay(dateObj, liburMap, ketLiburManualDiSheetCeklok) {
  const dateStr = Utilities.formatDate(dateObj, Session.getScriptTimeZone(), "dd/MM/yyyy");
  if (dateObj.getDay() === 0) return false; // Minggu bukan hari kerja (asumsi Sabtu hari kerja)
                                          // Jika Sabtu juga libur, tambahkan: || dateObj.getDay() === 6
  if (liburMap[dateStr]) return false; // Ada di kalender libur
  
  // Jika ada keterangan manual di Ceklok_Manual, tanggal itu tidak dianggap "kosong" yang perlu diisi.
  // Ini berarti guru sudah memberi alasan (sakit, izin, dll.)
  if (ketLiburManualDiSheetCeklok && ketLiburManualDiSheetCeklok.trim() !== "") {
    return false; 
  }
  return true;
}

/**
 * Memproses dan mengirim notifikasi untuk absensi yang tidak lengkap (jam masuk/pulang salah satu kosong).
 */
function processIncompleteAttendanceReminder(teacher, allCeklokData, ceklokHeaders, liburMap, reminderLogSheet, today, globalMinDateToCheck) {
  const idxCeklokNama = ceklokHeaders.indexOf("nama_guru");
  const idxCeklokTanggal = ceklokHeaders.indexOf("tanggal");
  const idxCeklokMasuk = ceklokHeaders.indexOf("jam_masuk");
  const idxCeklokPulang = ceklokHeaders.indexOf("jam_pulang");
  const idxCeklokKetManual = ceklokHeaders.indexOf("ket_libur_manual");

  // Periksa data dari globalMinDateToCheck hingga hari ini
  for (let i = 1; i < allCeklokData.length; i++) {
    const row = allCeklokData[i];
    const namaGuruDiSheet = String(row[idxCeklokNama]).trim();

    if (namaGuruDiSheet === teacher.name) {
      if (!(row[idxCeklokTanggal] instanceof Date)) continue;
      const tanggalAbsen = new Date(row[idxCeklokTanggal]);
      tanggalAbsen.setHours(0, 0, 0, 0);

      if (tanggalAbsen >= globalMinDateToCheck && tanggalAbsen <= today) {
        const ketLiburManualValue = row[idxCeklokKetManual] ? String(row[idxCeklokKetManual]).trim() : "";
        
        const isEffectivelyWorkDayForFillingHours =
            (tanggalAbsen.getDay() !== 0 && !liburMap[Utilities.formatDate(tanggalAbsen, Session.getScriptTimeZone(), "dd/MM/yyyy")]) &&
            (ketLiburManualValue === "");

        if (isEffectivelyWorkDayForFillingHours) {
          const jamMasuk = row[idxCeklokMasuk] ? String(row[idxCeklokMasuk]).trim() : "";
          const jamPulang = row[idxCeklokPulang] ? String(row[idxCeklokPulang]).trim() : "";

          if ((jamMasuk && !jamPulang) || (!jamMasuk && jamPulang)) {
            const tanggalAbsenStr = Utilities.formatDate(tanggalAbsen, Session.getScriptTimeZone(), "dd/MM/yyyy");
            const notifType = "tidak_lengkap"; // Tipe notifikasi untuk email dan in-app

            // Logika pengiriman email yang sudah ada:
            if (!helper_hasSentNotificationToday(reminderLogSheet, teacher.name, tanggalAbsenStr, notifType)) { //
              Logger.log(`Guru ${teacher.name} memiliki absensi tidak lengkap pada ${tanggalAbsenStr}. Mengirim email.`);
              const subject = `Pemberitahuan: Absensi Ceklok Tidak Lengkap - ${teacher.name}`;
              let body = `Yth. ${teacher.name},\n\n`;
              body += `Sistem kami mendeteksi bahwa data absensi Anda pada tanggal ${tanggalAbsenStr} belum lengkap.\n`;
              if (jamMasuk && !jamPulang) {
                body += `Anda telah mengisi jam masuk (${jamMasuk}), namun jam pulang masih kosong.\n`;
              } else { // !jamMasuk && jamPulang
                body += `Anda telah mengisi jam pulang (${jamPulang}), namun jam masuk masih kosong.\n`;
              }
              body += `Mohon untuk segera melengkapi data absensi Anda melalui aplikasi Ceklok.\n\nTerima kasih.\n${EMAIL_SENDER_NAME}`;
              
              if (teacher.email && helper_isValidEmailFormat(teacher.email)) { // Pastikan email valid sebelum mengirim
                try {
                  MailApp.sendEmail({
                    to: teacher.email,
                    subject: subject,
                    body: body,
                    name: EMAIL_SENDER_NAME
                  });
                  helper_logSentNotification(reminderLogSheet, teacher.name, tanggalAbsenStr, notifType, 0); // Urutan 0 untuk tipe ini //
                } catch (e) {
                  Logger.log(`Gagal mengirim email absensi tidak lengkap ke ${teacher.email} untuk tanggal ${tanggalAbsenStr}: ${e.toString()}`);
                }
              } else {
                Logger.log(`Email tidak valid atau tidak ada untuk ${teacher.name} (${teacher.email}). Email pengingat absensi tidak lengkap tidak dikirim untuk tanggal ${tanggalAbsenStr}.`);
              }
            }
          }
        }
      }
    }
  }
}


/**
 * Memproses dan mengirim notifikasi untuk pengisian absensi berkala (jika ada tanggal kosong).
 * Notifikasi dikirim setiap 3 hari jika kondisi terpenuhi.
 */
function processPeriodicEmptyAttendanceReminder(teacher, allCeklokData, ceklokHeaders, liburMap, reminderLogSheet, today, globalMinDateToCheck) {
  const idxCeklokNama = ceklokHeaders.indexOf("nama_guru");
  const idxCeklokTanggal = ceklokHeaders.indexOf("tanggal");
  const idxCeklokMasuk = ceklokHeaders.indexOf("jam_masuk");
  const idxCeklokPulang = ceklokHeaders.indexOf("jam_pulang");
  const idxCeklokKetManual = ceklokHeaders.indexOf("ket_libur_manual");

  // 1. Tentukan tanggal efektif terakhir guru mengisi data (baik jam atau keterangan)
  let lastEffectivelyFilledDate = null;
  for (let i = allCeklokData.length - 1; i >= 1; i--) {
    const row = allCeklokData[i];
    if (String(row[idxCeklokNama]).trim() === teacher.name) {
      if (!(row[idxCeklokTanggal] instanceof Date)) continue;
      const tanggalCek = new Date(row[idxCeklokTanggal]);
      tanggalCek.setHours(0, 0, 0, 0);

      if (tanggalCek < globalMinDateToCheck) continue;

      const jamMasuk = row[idxCeklokMasuk] ? String(row[idxCeklokMasuk]).trim() : "";
      const jamPulang = row[idxCeklokPulang] ? String(row[idxCeklokPulang]).trim() : "";
      const ketLiburManualValue = row[idxCeklokKetManual] ? String(row[idxCeklokKetManual]).trim() : "";

      if ((jamMasuk || jamPulang) || ketLiburManualValue) {
        lastEffectivelyFilledDate = tanggalCek;
        break;
      }
    }
  }

  // 2. Tentukan tanggal mulai pemeriksaan kekosongan
  let dateToCheckFrom;
  if (lastEffectivelyFilledDate) {
    dateToCheckFrom = new Date(lastEffectivelyFilledDate);
    dateToCheckFrom.setDate(lastEffectivelyFilledDate.getDate() + 1);
  } else {
    dateToCheckFrom = new Date(globalMinDateToCheck);
  }
  dateToCheckFrom.setHours(0,0,0,0);

  // 3. Cari hari kerja pertama yang kosong setelah tanggal terakhir diisi (atau globalMinDateToCheck)
  let firstEmptyWorkingDay = null;
  let tempDate = new Date(dateToCheckFrom);
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1); // Kita hanya peduli kekosongan sampai kemarin
  yesterday.setHours(0,0,0,0);

  while(tempDate <= yesterday) {
    const isAlreadyFilledOrHasKet = allCeklokData.some(row =>
        String(row[idxCeklokNama]).trim() === teacher.name &&
        row[idxCeklokTanggal] instanceof Date &&
        new Date(row[idxCeklokTanggal]).setHours(0,0,0,0) === tempDate.getTime() &&
        ((row[idxCeklokMasuk] && String(row[idxCeklokMasuk]).trim()) ||
         (row[idxCeklokPulang] && String(row[idxCeklokPulang]).trim()) ||
         (row[idxCeklokKetManual] && String(row[idxCeklokKetManual]).trim()))
    );

    const ketManualForTempDateRow = allCeklokData.find(row =>
        String(row[idxCeklokNama]).trim() === teacher.name &&
        row[idxCeklokTanggal] instanceof Date &&
        new Date(row[idxCeklokTanggal]).setHours(0,0,0,0) === tempDate.getTime()
    );
    const ketManualForTempDate = ketManualForTempDateRow ? String(ketManualForTempDateRow[idxCeklokKetManual]).trim() : "";

    if (helper_isWorkingDay(tempDate, liburMap, ketManualForTempDate) && !isAlreadyFilledOrHasKet) { //
      firstEmptyWorkingDay = new Date(tempDate);
      break;
    }
    tempDate.setDate(tempDate.getDate() + 1);
  }

  if (!firstEmptyWorkingDay) {
    return;
  }

  // 4. Logika pengiriman notifikasi berdasarkan interval 3 hari
  const targetEmptyDateStr = Utilities.formatDate(firstEmptyWorkingDay, Session.getScriptTimeZone(), "dd/MM/yyyy");
  const reminderTypeBase = "berkala_kosong"; // Tipe dasar untuk log

  const lastReminderRecord = helper_getLastPeriodicNotificationForTarget(reminderLogSheet, teacher.name, targetEmptyDateStr, reminderTypeBase); //

  let shouldSendToday = false;
  let newSequence = 1;

  if (!lastReminderRecord) {
    const ageOfEmptyDayInDays = Math.floor((today.getTime() - firstEmptyWorkingDay.getTime()) / (1000 * 60 * 60 * 24));
    if (ageOfEmptyDayInDays >= 1) {
        shouldSendToday = true;
        newSequence = 1;
    }
  } else {
    const lastReminderDate = new Date(lastReminderRecord.tanggalKirim);
    lastReminderDate.setHours(0,0,0,0);
    const daysSinceLastReminderForTarget = Math.floor((today.getTime() - lastReminderDate.getTime()) / (1000 * 60 * 60 * 24));

    if (daysSinceLastReminderForTarget >= 3) {
      shouldSendToday = true;
      newSequence = lastReminderRecord.urutan + 1;
    }
  }

  if (shouldSendToday) {
    const specificNotifTypeForLogEmail = `${reminderTypeBase}_${newSequence}`; // e.g., "berkala_kosong_1" - untuk log email
    const inAppNotifType = `MISSING_CEKLOK_PERIODIC_${newSequence}`; // Tipe spesifik untuk in-app

    // Logika pengiriman email yang sudah ada:
    if (!helper_hasSentNotificationToday(reminderLogSheet, teacher.name, targetEmptyDateStr, specificNotifTypeForLogEmail)) { //
        const actualLastFilledDateStr = lastEffectivelyFilledDate ? Utilities.formatDate(lastEffectivelyFilledDate, Session.getScriptTimeZone(), "dd/MM/yyyy") : "belum ada catatan";
        Logger.log(`Mengirim notifikasi pengisian berkala (Urutan: ${newSequence}, Interval 3 hari terpenuhi) ke ${teacher.name}. Absen terakhir diisi: ${actualLastFilledDateStr}. Target kosong: ${targetEmptyDateStr}.`);

        const subject = `Pengingat Pengisian Absensi Ceklok - ${teacher.name}`;
        let body = `Yth. ${teacher.name},\n\n`;
        body += `Sistem kami mengingatkan bahwa Anda belum mengisi data absensi Ceklok setidaknya untuk tanggal ${targetEmptyDateStr}.\n`;
        if(lastEffectivelyFilledDate){
            body += `Tanggal absensi terakhir Anda yang tercatat adalah ${actualLastFilledDateStr}.\n\n`;
        } else {
            body += `Kami belum menemukan catatan absensi dari Anda sejak periode ${Utilities.formatDate(globalMinDateToCheck, Session.getScriptTimeZone(), "dd/MM/yyyy")}.\n\n`;
        }
        body += `Mohon untuk segera mengisi data absensi Anda melalui aplikasi Ceklok MTS Tanuntung.\n\n`;
        body += `Terima kasih.\n${EMAIL_SENDER_NAME}`; //

        if (teacher.email && helper_isValidEmailFormat(teacher.email)) { //
            try {
                MailApp.sendEmail({
                  to: teacher.email,
                  subject: subject,
                  body: body,
                  name: EMAIL_SENDER_NAME //
                });
                helper_logSentNotification(reminderLogSheet, teacher.name, targetEmptyDateStr, specificNotifTypeForLogEmail, newSequence); //
            } catch (e) {
                Logger.log(`Gagal mengirim email pengingat berkala ke ${teacher.email} untuk ${targetEmptyDateStr}: ${e.toString()}`);
            }
        } else {
            Logger.log(`Email tidak valid atau tidak ada untuk ${teacher.name} (${teacher.email}). Email pengingat berkala tidak dikirim untuk tanggal ${targetEmptyDateStr}.`);
        }
    } else {
        Logger.log(`Notifikasi pengisian berkala (Urutan: ${newSequence}) untuk ${teacher.name} target ${targetEmptyDateStr} sudah dikirim hari ini (dicegah duplikasi email).`);
    }
  }
}

/**
 * Helper: Mendapatkan log notifikasi BERKALA terakhir untuk guru & target tanggal tertentu.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} reminderLogSheet Sheet log.
 * @param {string} teacherName Nama guru.
 * @param {string} targetDateStr Tanggal target absensi yang kosong (dd/MM/yyyy).
 * @param {string} baseNotifType Tipe dasar notifikasi berkala (misal "berkala_kosong").
 * @return {object|null} Objek log terakhir atau null jika tidak ada.
 */
function helper_getLastPeriodicNotificationForTarget(reminderLogSheet, teacherName, targetDateStr, baseNotifType) {
    if (!reminderLogSheet) return null;
    const logData = reminderLogSheet.getDataRange().getValues();
    let lastNotificationRecord = null;

    for (let i = logData.length - 1; i >= 1; i--) { // Cek dari terbaru
        const row = logData[i];
        // Kolom: Nama_Guru (0), Target_Tanggal_Absen (1), Tipe_Notifikasi (2), Tanggal_Notifikasi_Terkirim (3), Urutan_Pengingat_Berkala (4)
        const logTeacher = String(row[0]).trim();
        const logTargetDate = String(row[1]).trim();
        const logNotifTypeFull = String(row[2]).trim(); // e.g., "berkala_kosong_1"
        const logSentTimestamp = row[3];
        const logSequence = row[4] ? parseInt(row[4]) : 0;
        
        let logSentDate = null;
        if (logSentTimestamp instanceof Date) {
            logSentDate = new Date(logSentTimestamp);
        } else if (typeof logSentTimestamp === 'string' && logSentTimestamp) {
            try { logSentDate = new Date(logSentTimestamp); } catch(e) {}
        } else if (typeof logSentTimestamp === 'number') {
            logSentDate = new Date(logSentTimestamp);
        }

        if (logTeacher === teacherName && logTargetDate === targetDateStr && logNotifTypeFull.startsWith(baseNotifType)) {
             // Kita cari yang paling baru berdasarkan tanggal kirim, lalu urutan
            if (logSentDate) {
                if (!lastNotificationRecord || logSentDate > new Date(lastNotificationRecord.tanggalKirim) || (logSentDate.getTime() === new Date(lastNotificationRecord.tanggalKirim).getTime() && logSequence > lastNotificationRecord.urutan) ) {
                    lastNotificationRecord = {
                        teacher: logTeacher,
                        target: logTargetDate,
                        type: logNotifTypeFull,
                        tanggalKirim: logSentDate,
                        urutan: logSequence
                    };
                }
            }
        }
    }
    return lastNotificationRecord;
}


// --- Fungsi untuk membuat/memastikan trigger harian ada ---
function createOrEnsureDailyReminderTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  let triggerExists = false;
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === "checkAndSendAttendanceReminders") {
      triggerExists = true;
      Logger.log("Trigger harian 'checkAndSendAttendanceReminders' sudah ada.");
      break;
    }
  }

  if (!triggerExists) {
    ScriptApp.newTrigger("checkAndSendAttendanceReminders")
      .timeBased()
      .everyDays(1)       // Setiap hari
      .atHour(7)          // Sekitar jam 7 pagi (sesuaikan)
      .nearMinute(15)     // Variasi menit untuk menghindari beban server bersamaan
      .inTimezone(Session.getScriptTimeZone()) // Gunakan timezone spreadsheet
      .create();
    Logger.log("Trigger harian 'checkAndSendAttendanceReminders' berhasil dibuat.");
  }
}

/**
 * Mengambil ringkasan kehadiran bulanan untuk seorang guru.
 * LOGIKA BARU (Disempurnakan):
 * 1. Alpa dihitung untuk seluruh hari kerja dalam sebulan.
 * 2. Kondisi "Ceklok Tidak Lengkap" (salah satu jam terisi) DIHITUNG sebagai "Alpa".
 * 3. Kategori "Ceklok Tidak Lengkap" TETAP DITAMPILKAN jumlahnya dan bisa diklik, namun hanya sebagai informasi tambahan dan tidak mempengaruhi perhitungan persentase.
 *
 * @param {string} teacherName Nama guru.
 * @param {string} monthYear Periode bulan dan tahun (format "MM/YYYY").
 * @return {object} Objek yang berisi statistik ringkasan atau error.
 */
function getTeacherMonthlySummary(teacherName, monthYear) {
  try {
    if (!teacherName || !monthYear || !/^\d{2}\/\d{4}$/.test(monthYear)) {
      return { success: false, error: "Nama guru dan periode (MM/YYYY) harus valid." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const kalenderSheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    const opsiKetLiburSheet = ss.getSheetByName(OPSIKETLIBUR_SHEET_NAME);

    if (!ceklokManualSheet) return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };
    if (!kalenderSheet) return { success: false, error: `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan.` };

    const [mmStr, quadripleStr] = monthYear.split("/");
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(quadripleStr, 10);

    const lastDayOfMonth = new Date(yyyy, mm, 0).getDate();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const liburMap = {};
    if (kalenderSheet.getLastRow() > 1) {
      const kalenderData = kalenderSheet.getRange(2, 1, kalenderSheet.getLastRow() - 1, 2).getDisplayValues();
      kalenderData.forEach(row => {
        if (row[0] && String(row[0]).trim() !== "") {
          liburMap[String(row[0]).trim()] = String(row[1]).trim() || "Hari Libur Nasional";
        }
      });
    }

    let allValidReasonsFromSheet = [];
    if (opsiKetLiburSheet && opsiKetLiburSheet.getLastRow() > 1) {
      allValidReasonsFromSheet = opsiKetLiburSheet.getRange(2, 1, opsiKetLiburSheet.getLastRow() - 1, 1)
                                      .getValues().flat().filter(String).map(o => String(o).trim().toLowerCase());
    }

    const allCeklokData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = allCeklokData[0].map(h => String(h).trim().toLowerCase());
    const idxNama = ceklokHeaders.indexOf("nama_guru");
    const idxTanggal = ceklokHeaders.indexOf("tanggal");
    const idxMasuk = ceklokHeaders.indexOf("jam_masuk");
    const idxPulang = ceklokHeaders.indexOf("jam_pulang");
    const idxKetManual = ceklokHeaders.indexOf("ket_libur_manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap." };
    }

    let summary = {
      teacherName: teacherName,
      monthYear: monthYear,
      totalWorkingDaysInMonth: 0,
      effectiveWorkingDaysPassed: 0,
      completedChecklok: 0,
      present: 0,
      schoolHoliday: 0,
      otherValidReason: 0,
      absent: 0,
      incomplete: 0, // Dihitung kembali untuk ditampilkan
      attendancePercentage: 0,
      absentDates: [],
      incompleteEntries: [] // Dihitung kembali untuk detail modal
    };

    for (let day = 1; day <= lastDayOfMonth; day++) {
      const currentDate = new Date(yyyy, mm - 1, day);
      currentDate.setHours(0,0,0,0);
      const dateStr = Utilities.formatDate(currentDate, Session.getScriptTimeZone(), "dd/MM/yyyy");
      const dayOfWeek = currentDate.getDay();

      let isWorkingDay = (dayOfWeek !== 0 && !liburMap[dateStr]);

      if (isWorkingDay) {
        summary.totalWorkingDaysInMonth++;
        if (currentDate <= today) {
            summary.effectiveWorkingDaysPassed++;
        }

        let isDayComplete = false;
        let entryFound = false;

        for (let k = 1; k < allCeklokData.length; k++) {
            const row = allCeklokData[k];
            if (String(row[idxNama]).trim() === teacherName &&
                row[idxTanggal] instanceof Date &&
                Utilities.formatDate(new Date(row[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === dateStr) {
                
                entryFound = true;
                const jamMasuk = String(row[idxMasuk] || "").trim();
                const jamPulang = String(row[idxPulang] || "").trim();
                const ketManual = String(row[idxKetManual] || "").trim();

                if (jamMasuk && jamPulang) {
                    summary.present++;
                    isDayComplete = true;
                } else if ((jamMasuk && !jamPulang) || (!jamMasuk && jamPulang)) {
                    // --- PERUBAHAN LOGIKA DI SINI ---
                    // Tetap hitung 'incomplete' untuk ditampilkan, tapi hari ini tidak dianggap 'complete'
                    summary.incomplete++;
                    let missingDetail = jamMasuk ? "Jam Pulang Kosong" : "Jam Masuk Kosong";
                    summary.incompleteEntries.push({ date: dateStr, missing: missingDetail });
                    isDayComplete = false; // Tetap false agar dihitung Alpa
                } else if (ketManual) {
                    const ketManualLower = ketManual.toLowerCase();
                    if (ketManualLower.includes("hari libur sekolah") || ketManualLower.includes("libur sekolah")) {
                        summary.schoolHoliday++;
                        isDayComplete = true;
                    } else if (allValidReasonsFromSheet.includes(ketManualLower)) {
                        summary.otherValidReason++;
                        isDayComplete = true;
                    }
                }
                break;
            }
        }

        if (!isDayComplete) {
            summary.absent++;
            // Hanya tambahkan ke absentDates jika BUKAN kasus incomplete, agar tidak duplikat di modal
            if (!summary.incompleteEntries.some(e => e.date === dateStr)) {
                summary.absentDates.push(dateStr);
            }
        }
      }
    }

    summary.completedChecklok = summary.present + summary.schoolHoliday + summary.otherValidReason;
    
    if (summary.totalWorkingDaysInMonth > 0) {
      summary.attendancePercentage = parseFloat(((summary.completedChecklok / summary.totalWorkingDaysInMonth) * 100).toFixed(2));
    } else {
      summary.attendancePercentage = 0;
    }

    return { success: true, summary: summary };

  } catch (e) {
    Logger.log(`Error in getTeacherMonthlySummary (teacher: ${teacherName}, month: ${monthYear}): ${e.toString()}\nStack: ${e.stack}`);
    return { success: false, error: `Gagal mengambil ringkasan: ${e.message}` };
  }
}


// GANTI FUNGSI getLockedMonths YANG ADA DENGAN VERSI INI
// DI DALAM FILE code.gs.html

/**
 * Mengambil daftar semua bulan yang terkunci.
 * @return {object} Objek dengan properti 'months' (array string "MM/YYYY") atau 'error'.
 */
function getLockedMonths() {
  try {
    const sheet = ensureSheet(LOCKED_MONTHS_SHEET_NAME, ["LockedMonthYear"]); // Pastikan sheet ada
    if (sheet.getLastRow() < 2) {
      return { success: true, months: [] }; // Tidak ada bulan terkunci jika hanya header atau kosong
    }
    // GUNAKAN .getDisplayValues() di sini agar mendapatkan format string "MM/YYYY"
    const lockedMonths = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1)
                                .getDisplayValues() // <--- PERUBAHAN UTAMA DI SINI
                                .flat()
                                .filter(String) // Menghilangkan baris kosong jika ada
                                .map(m => String(m).trim()); // Pastikan tetap string dan di-trim
    
    Logger.log(`getLockedMonths (setelah perbaikan): Ditemukan bulan terkunci: ${JSON.stringify(lockedMonths)}`);
    return { success: true, months: lockedMonths };
  } catch (e) {
    Logger.log(`Error in getLockedMonths: ${e.toString()}`);
    return { success: false, error: `Gagal mengambil daftar bulan terkunci: ${e.message}` };
  }
}

/**
 * Mengunci sebuah bulan.
 * @param {string} monthYearToLock Bulan yang akan dikunci (format "MM/YYYY").
 * @return {object} Hasil operasi {success: boolean, message/error: string}.
 */
function lockMonth(monthYearToLock, actingUserUsername, actingUserRole) {
  try {
    if (!monthYearToLock || !/^\d{2}\/\d{4}$/.test(monthYearToLock)) {
      logUserActivity(actingUserUsername, actingUserRole, "LOCK_MONTH_FAIL", monthYearToLock, "Format Bulan/Tahun tidak valid", "FAIL");
      return { success: false, error: "Format Bulan/Tahun tidak valid (MM/YYYY)." };
    }

    const sheet = ensureSheet(LOCKED_MONTHS_SHEET_NAME, ["LockedMonthYear"]);
    const currentLocked = getLockedMonths().months || [];

    if (currentLocked.includes(monthYearToLock)) {
      logUserActivity(actingUserUsername, actingUserRole, "LOCK_MONTH_FAIL", monthYearToLock, "Bulan sudah terkunci", "FAIL");
      return { success: false, error: `Bulan ${monthYearToLock} sudah terkunci.` };
    }

    sheet.appendRow([monthYearToLock]);
    SpreadsheetApp.flush();
    logUserActivity(actingUserUsername, actingUserRole, "LOCK_MONTH_SUCCESS", monthYearToLock, "", "SUCCESS");
    return { success: true, message: `Bulan ${monthYearToLock} berhasil dikunci.` };
  } catch (e) {
    Logger.log(`Error in lockMonth (${monthYearToLock}): ${e.toString()}`);
    logUserActivity(actingUserUsername, actingUserRole, "LOCK_MONTH_ERROR", monthYearToLock, e.message, "ERROR");
    return { success: false, error: `Gagal mengunci bulan: ${e.message}` };
  }
}

// Di dalam file code.gs.html

/**
 * Membuka kunci sebuah bulan.
 * @param {string} monthYearToUnlock Bulan yang akan dibuka kuncinya (format "MM/YYYY").
 * @return {object} Hasil operasi {success: boolean, message/error: string}.
 */
function unlockMonth(monthYearToUnlock) {
  try {
    if (!monthYearToUnlock || !/^\d{2}\/\d{4}$/.test(monthYearToUnlock)) {
      Logger.log(`unlockMonth: Format monthYearToUnlock tidak valid: ${monthYearToUnlock}`);
      logUserActivity(actingUserUsername, actingUserRole, "UNLOCK_MONTH_FAIL", monthYearToUnlock, "Format Bulan/Tahun tidak valid", "FAIL");
      return { success: false, error: "Format Bulan/Tahun yang akan dibuka kuncinya tidak valid (MM/YYYY)." };
    }
    Logger.log(`unlockMonth: Mencoba membuka kunci untuk bulan: ${monthYearToUnlock}`);

    const sheet = ensureSheet(LOCKED_MONTHS_SHEET_NAME, ["LockedMonthYear"]);
    // Gunakan getDisplayValues() untuk konsistensi dengan bagaimana getLockedMonths() membaca
    // dan bagaimana bulanTahun disimpan (sebagai string "MM/YYYY").
    const data = sheet.getDataRange().getDisplayValues(); // <--- Pastikan menggunakan getDisplayValues()
    let rowIndexToDelete = -1;
    let monthFound = false;

    Logger.log(`unlockMonth: Data mentah dari sheet Locked_Months: ${JSON.stringify(data)}`);

    // Iterasi dimulai dari i = 1 karena baris pertama (indeks 0) adalah header.
    for (let i = 1; i < data.length; i++) {
      const lockedMonthInSheet = String(data[i][0]).trim(); // Kolom pertama (indeks 0) berisi LockedMonthYear
      Logger.log(`unlockMonth: Membandingkan '${monthYearToUnlock}' dengan '${lockedMonthInSheet}' di baris sheet ${i + 1}`);
      if (lockedMonthInSheet === monthYearToUnlock) {
        rowIndexToDelete = i + 1; // Nomor baris di sheet (1-based) untuk deleteRow()
        Logger.log(`unlockMonth: Bulan ${monthYearToUnlock} ditemukan di baris sheet ${rowIndexToDelete}. Akan dihapus.`);
        break;
      }
    }

    if (rowIndexToDelete !== -1) {
      sheet.deleteRow(rowIndexToDelete);
      SpreadsheetApp.flush(); // Pastikan perubahan langsung diterapkan
      Logger.log(`unlockMonth: Kunci untuk bulan ${monthYearToUnlock} berhasil dibuka.`);
      return { success: true, message: `Kunci untuk bulan ${monthYearToUnlock} berhasil dibuka.` };
    } else {
      Logger.log(`unlockMonth: Bulan ${monthYearToUnlock} tidak ditemukan dalam daftar terkunci untuk dihapus.`);
      return { success: false, error: `Bulan ${monthYearToUnlock} tidak ditemukan dalam daftar terkunci.` };
    }

    if (monthFound) {
      sheet.deleteRow(rowIndexToDelete);
      SpreadsheetApp.flush();
      logUserActivity(actingUserUsername, actingUserRole, "UNLOCK_MONTH_SUCCESS", monthYearToUnlock, "", "SUCCESS");
      return { success: true, message: `Kunci untuk bulan ${monthYearToUnlock} berhasil dibuka.` };
    } else {
      logUserActivity(actingUserUsername, actingUserRole, "UNLOCK_MONTH_FAIL", monthYearToUnlock, "Bulan tidak ditemukan dalam daftar terkunci", "FAIL");
      return { success: false, error: `Bulan ${monthYearToUnlock} tidak ditemukan dalam daftar terkunci.` };
    }

  } catch (e) {
    Logger.log(`Error in unlockMonth (${monthYearToUnlock}): ${e.toString()}\nStack: ${e.stack}`);
    logUserActivity(actingUserUsername, actingUserRole, "UNLOCK_MONTH_ERROR", monthYearToUnlock, e.message, "ERROR");
    return { success: false, error: `Gagal membuka kunci bulan: ${e.message}` };
  }
}

// Tambahkan fungsi baru ini di code.gs

/**
 * Mencatat aktivitas pengguna ke dalam sheet Activity_Log.
 * @param {string} actorUsername Username pengguna yang melakukan aksi. Bisa "SYSTEM" atau "ANONYMOUS".
 * @param {string} actorRole Peran pengguna yang melakukan aksi. Bisa "N/A".
 * @param {string} actionType Deskripsi jenis aksi (e.g., "LOGIN_SUCCESS", "CREATE_USER").
 * @param {string} [targetEntity=null] Entitas utama yang dipengaruhi (e.g., username yang diubah).
 * @param {string} [details=""] Detail tambahan tentang aksi tersebut.
 * @param {string} [status="INFO"] Status aksi (e.g., "SUCCESS", "FAIL", "INFO").
 */
function logUserActivity(actorUsername, actorRole, actionType, targetEntity, details, status) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Pastikan sheet log ada dan memiliki header yang benar
    const logSheet = ensureSheet(ACTIVITY_LOG_SHEET_NAME, [
      "Timestamp",          // Kolom 1
      "ActorUsername",      // Kolom 2
      "ActorRole",          // Kolom 3
      "ActionType",         // Kolom 4
      "TargetEntity",       // Kolom 5
      "Details",            // Kolom 6
      "Status"              // Kolom 7
    ]);

    const timestamp = new Date(); // Waktu saat ini

    logSheet.appendRow([
      timestamp,
      actorUsername || "N/A",
      actorRole || "N/A",
      actionType || "UNDEFINED_ACTION",
      targetEntity || "", // Default ke string kosong jika null atau undefined
      details || "",      // Default ke string kosong
      status || "INFO"    // Default status
    ]);
  } catch (e) {
    // Catat error jika gagal menulis log, agar tidak mengganggu fungsi utama
    Logger.log(`GAGAL MENCATAT LOG AKTIVITAS PENGGUNA: ${e.toString()}. ` +
               `Aktor: ${actorUsername}, Peran: ${actorRole}, Aksi: ${actionType}, ` +
               `Target: ${targetEntity}, Detail: ${details}, Status: ${status}`);
    // Pertimbangkan untuk tidak menampilkan error ini ke pengguna,
    // kecuali jika proses logging ini sangat kritikal.
  }
}

// Di dalam file code.gs
// Pastikan konstanta peran (ROLE_SUPERADMIN) dan ACTIVITY_LOG_SHEET_NAME sudah ada

/**
 * Mengambil data log aktivitas dengan opsi filter dan paginasi.
 * Hanya bisa diakses oleh Superadmin.
 * @param {string} actingUserRole Peran pengguna yang meminta data.
 * @param {object} [options={}] Opsi untuk filter dan paginasi.
 * @param {number} [options.limit=50] Jumlah maksimum entri yang diambil per halaman.
 * @param {number} [options.offset=0] Offset (jumlah data yang dilewati) untuk paginasi.
 * @param {string} [options.filterUsername=""] Filter berdasarkan username aktor (case-insensitive contains).
 * @param {string} [options.filterActionType=""] Filter berdasarkan jenis aksi (case-insensitive contains).
 * @param {string} [options.filterStartDate=null] Filter tanggal mulai (format ISO string YYYY-MM-DDTHH:mm:ss.sssZ atau YYYY-MM-DD).
 * @param {string} [options.filterEndDate=null] Filter tanggal akhir (format ISO string YYYY-MM-DDTHH:mm:ss.sssZ atau YYYY-MM-DD).
 * @return {object} Objek berisi { success: boolean, logs: array, totalFilteredLogs?: number, error?: string }.
 */
// Di dalam file code.gs
// Fungsi getActivityLogData yang sudah dimodifikasi

// Di dalam file code.gs.html

// Fungsi getActivityLogData yang sudah dimodifikasi untuk parsing timestamp yang lebih baik
// dan menerima parameter sortir

function getActivityLogData(actingUserRole, options = {}) {
  if (actingUserRole !== ROLE_SUPERADMIN) {
    return { success: false, error: "Akses ditolak. Hanya Superadmin yang dapat melihat log aktivitas." };
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const logSheet = ss.getSheetByName(ACTIVITY_LOG_SHEET_NAME);

    if (!logSheet) {
      return { success: false, error: `Sheet log aktivitas '${ACTIVITY_LOG_SHEET_NAME}' tidak ditemukan.` };
    }
    if (logSheet.getLastRow() < 2) {
      return { success: true, logs: [], totalFilteredLogs: 0, message: "Belum ada aktivitas yang tercatat." };
    }

    // Ambil semua data (baris ke-2 sampai terakhir, 7 kolom)
    const logSheetRange = logSheet.getRange(2, 1, logSheet.getLastRow() - 1, 7);
    const allLogRawValues = logSheetRange.getValues(); // Untuk timestamp jika berupa Date object
    const allLogDisplayValues = logSheetRange.getDisplayValues(); // Untuk semua field lainnya

    let mappedLogs = allLogRawValues.map((row, index) => {
      const displayRow = allLogDisplayValues[index];
      let timestampObject;
      // Kolom pertama (indeks 0) adalah Timestamp
      if (row[0] instanceof Date) {
        timestampObject = row[0];
      } else {
        // Coba parsing display value. Ini mungkin perlu penyesuaian berdasarkan format tanggal di sheet Anda.
        // Asumsi format umum yang bisa diparse atau dd/MM/yyyy HH:mm:ss
        let tsString = displayRow[0];
        let parsedDate = new Date(tsString); // Coba parsing langsung
        if (isNaN(parsedDate.getTime())) { // Jika gagal, coba format dd/MM/yyyy HH:mm:ss
            const parts = tsString.match(/(\d{2})\/(\d{2})\/(\d{4})\s*(\d{2}):(\d{2}):(\d{2})/);
            if (parts) {
                // parts[1]=dd, parts[2]=MM, parts[3]=yyyy, parts[4]=HH, parts[5]=mm, parts[6]=ss
                parsedDate = new Date(parts[3], parseInt(parts[2],10) - 1, parts[1], parts[4], parts[5], parts[6]);
            } else { // Coba format dd/MM/yyyy saja (jika tidak ada waktu)
                const datePartsOnly = tsString.match(/(\d{2})\/(\d{2})\/(\d{4})/);
                if(datePartsOnly){
                    parsedDate = new Date(datePartsOnly[3], parseInt(datePartsOnly[2],10) - 1, datePartsOnly[1]);
                } else {
                    parsedDate = null; // Tidak bisa diparse
                    Logger.log("Timestamp tidak dapat diparse: " + tsString);
                }
            }
        }
        timestampObject = parsedDate;
      }

      return {
        timestamp: displayRow[0], // Selalu kirim string display ke client
        timestamp_internal_sort: timestampObject, // Untuk sorting internal
        actorUsername: displayRow[1],
        actorRole: displayRow[2],
        actionType: displayRow[3],
        targetEntity: displayRow[4],
        details: displayRow[5],
        status: displayRow[6]
      };
    }).filter(log => log.timestamp_internal_sort instanceof Date); // Hanya proses log dengan timestamp valid

    // --- Implementasi Filter (dari kode Anda sebelumnya) ---
    const { filterUsername, filterActionType, filterStartDateString, filterEndDateString } = options;
    let filteredLogs = mappedLogs;

    if (filterUsername && filterUsername.trim() !== "") {
      const searchTerm = filterUsername.trim().toLowerCase();
      filteredLogs = filteredLogs.filter(log => log.actorUsername.toLowerCase().includes(searchTerm));
    }
    if (filterActionType && filterActionType.trim() !== "") {
      const searchTerm = filterActionType.trim().toLowerCase();
      filteredLogs = filteredLogs.filter(log => log.actionType.toLowerCase().includes(searchTerm));
    }

    if (filterStartDateString) {
      try {
        const [year, month, day] = filterStartDateString.split('-').map(Number);
        const startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        filteredLogs = filteredLogs.filter(log => log.timestamp_internal_sort >= startDate);
      } catch (e) { Logger.log(`Error parsing filterStartDateString: ${e.message}`); }
    }

    if (filterEndDateString) {
      try {
        const [year, month, day] = filterEndDateString.split('-').map(Number);
        const endDate = new Date(year, month - 1, day, 23, 59, 59, 999);
        filteredLogs = filteredLogs.filter(log => log.timestamp_internal_sort <= endDate);
      } catch (e) { Logger.log(`Error parsing filterEndDateString: ${e.message}`); }
    }
    // --- Akhir Implementasi Filter ---

    // --- Implementasi Sorting ---
    const sortBy = options.sortBy || 'timestamp_internal_sort'; // Default sort
    const sortDir = options.sortDir || 'desc'; // Default descending

    filteredLogs.sort((a, b) => {
      let valA = a[sortBy];
      let valB = b[sortBy];

      if (sortBy === 'timestamp_internal_sort') {
        valA = valA instanceof Date ? valA.getTime() : 0;
        valB = valB instanceof Date ? valB.getTime() : 0;
      } else { // Untuk kolom string
        valA = String(valA || "").toLowerCase(); // Tangani null/undefined dengan string kosong
        valB = String(valB || "").toLowerCase();
      }

      let comparison = 0;
      if (valA > valB) {
        comparison = 1;
      } else if (valA < valB) {
        comparison = -1;
      }
      return (sortDir === 'desc' ? (comparison * -1) : comparison);
    });
    // --- Akhir Implementasi Sorting ---

    const totalFilteredLogs = filteredLogs.length;
    const limit = parseInt(options.limit, 10) || 30; // Sesuaikan default limit jika perlu
    const offset = parseInt(options.offset, 10) || 0;
    
    // Hapus field internal sebelum kirim ke client
    const paginatedLogs = filteredLogs.slice(offset, offset + limit).map(log => {
        const { timestamp_internal_sort, ...clientLog } = log;
        return clientLog;
    });

    return { success: true, logs: paginatedLogs, totalFilteredLogs: totalFilteredLogs };

  } catch (e) {
    Logger.log(`Error di getActivityLogData (options: ${JSON.stringify(options)}): ${e.toString()}\nStack: ${e.stack}`);
    logUserActivity("SYSTEM", "N/A", "GET_ACTIVITY_LOG_ERROR", "", `Options: ${JSON.stringify(options)}, Error: ${e.message}`, "ERROR");
    return { success: false, error: `Gagal mengambil log aktivitas: ${e.message}` };
  }
}

// Add this function to your code.gs

/**
 * Mengambil ringkasan kehadiran bulanan untuk SEMUA guru.
 * Hanya bisa diakses oleh Superadmin.
 * @param {string} monthYear Periode bulan dan tahun (format "MM/YYYY").
 * @param {string} actingUserRole Peran pengguna yang meminta (untuk verifikasi Superadmin).
 * @return {object} Objek yang berisi statistik ringkasan atau error.
 */
function getOverallMonthlySummaryForAllTeachers(monthYear, actingUserRole) {
  if (actingUserRole !== ROLE_SUPERADMIN) {
    return { success: false, error: "Akses ditolak. Fungsi ini hanya untuk Superadmin." };
  }

  try {
    if (!monthYear || !/^\d{2}\/\d{4}$/.test(monthYear)) {
      return { success: false, error: "Periode (MM/YYYY) harus valid." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const namaGuruSheet = ss.getSheetByName(NAMA_GURU_SHEET_NAME);
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const kalenderSheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    const opsiKetLiburSheet = ss.getSheetByName(OPSIKETLIBUR_SHEET_NAME);

    if (!namaGuruSheet) return { success: false, error: `Sheet '${NAMA_GURU_SHEET_NAME}' tidak ditemukan.` };
    if (!ceklokManualSheet) return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };
    if (!kalenderSheet) return { success: false, error: `Sheet '${KALENDER_SHEET_NAME}' tidak ditemukan.` };
    // opsiKetLiburSheet is optional for this core logic but good to check if used for "OtherValidReason" validation
    if (!opsiKetLiburSheet) Logger.log(`Peringatan: Sheet '${OPSIKETLIBUR_SHEET_NAME}' tidak ditemukan. Validasi alasan lain mungkin terbatas.`);


    const daftarNamaGuru = namaGuruSheet.getLastRow() > 0 ?
                           namaGuruSheet.getRange(1, 1, namaGuruSheet.getLastRow(), 1)
                                      .getValues().flat().filter(String).map(g => String(g).trim()) :
                           [];
    if (daftarNamaGuru.length === 0) {
      return { success: true, message: "Tidak ada data guru untuk ditampilkan.", monthYear: monthYear, totalWorkingDaysInMonth: 0, effectiveWorkingDaysPassed: 0, allTeachersSummary: [] };
    }

    const [mmStr, yyyyStr] = monthYear.split("/");
    const mm = parseInt(mmStr, 10);
    const yyyy = parseInt(yyyyStr, 10);

    const lastDayOfMonth = new Date(yyyy, mm, 0).getDate();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const liburMap = {}; // From Kalender_Pendidikan
    if (kalenderSheet.getLastRow() > 1) {
      const kalenderData = kalenderSheet.getRange(2, 1, kalenderSheet.getLastRow() - 1, 2).getDisplayValues();
      kalenderData.forEach(row => {
        if (row[0] && String(row[0]).trim() !== "") {
          liburMap[String(row[0]).trim()] = String(row[1]).trim() || "Hari Libur";
        }
      });
    }

    let allValidReasonsFromSheet = [];
    if (opsiKetLiburSheet && opsiKetLiburSheet.getLastRow() > 1) {
      allValidReasonsFromSheet = opsiKetLiburSheet.getRange(2, 1, opsiKetLiburSheet.getLastRow() - 1, 1)
                                      .getValues().flat().filter(String).map(o => String(o).trim().toLowerCase());
    }

    const allCeklokData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = allCeklokData[0].map(h => String(h).trim().toLowerCase());
    const idxNama = ceklokHeaders.indexOf("nama_guru");
    const idxTanggal = ceklokHeaders.indexOf("tanggal");
    const idxMasuk = ceklokHeaders.indexOf("jam_masuk");
    const idxPulang = ceklokHeaders.indexOf("jam_pulang");
    const idxKetManual = ceklokHeaders.indexOf("ket_libur_manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap." };
    }

    // Calculate global month stats
    let totalWorkingDaysInMonth = 0;
    let effectiveWorkingDaysPassed = 0;
    for (let day = 1; day <= lastDayOfMonth; day++) {
      const currentDate = new Date(yyyy, mm - 1, day);
      const dateStr = Utilities.formatDate(currentDate, Session.getScriptTimeZone(), "dd/MM/yyyy");
      const dayOfWeek = currentDate.getDay(); // 0 for Sunday, 6 for Saturday

      let isDefinitelyHoliday = false;
      if (dayOfWeek === 0) { // Sunday is a holiday
        isDefinitelyHoliday = true;
      } else if (liburMap[dateStr]) { // Holiday from Kalender Pendidikan
        isDefinitelyHoliday = true;
      }

      if (!isDefinitelyHoliday) {
        totalWorkingDaysInMonth++;
        if (currentDate <= today) {
          effectiveWorkingDaysPassed++;
        }
      }
    }

    const allTeachersSummary = [];

    for (const teacherName of daftarNamaGuru) {
      let teacherSummary = {
        teacherName: teacherName,
        completedChecklokCount: 0,
        presentDetails: [],
        schoolHolidayDetails: [],
        otherValidReasonDetails: [],
        absentDetails: [],
        incompleteDetails: [],
        attendancePercentage: 0
      };

      for (let day = 1; day <= lastDayOfMonth; day++) {
        const currentDate = new Date(yyyy, mm - 1, day);
        currentDate.setHours(0,0,0,0);
        const dateStr = Utilities.formatDate(currentDate, Session.getScriptTimeZone(), "dd/MM/yyyy");
        const dayOfWeek = currentDate.getDay();

        let isBaseWorkingDay = true; // Is it a working day before considering teacher's specific input?
        if (dayOfWeek === 0 || liburMap[dateStr]) {
          isBaseWorkingDay = false;
        }

        let entryProcessed = false;
        for (let k = 1; k < allCeklokData.length; k++) {
          const row = allCeklokData[k];
          if (String(row[idxNama]).trim() === teacherName &&
              row[idxTanggal] instanceof Date &&
              Utilities.formatDate(new Date(row[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === dateStr) {
            
            const jamMasuk = String(row[idxMasuk] || "").trim();
            const jamPulang = String(row[idxPulang] || "").trim();
            const ketManual = String(row[idxKetManual] || "").trim();

            if (ketManual) {
              const ketManualLower = ketManual.toLowerCase();
              if (ketManualLower.includes("hari libur sekolah") || ketManualLower.includes("libur sekolah")) {
                teacherSummary.schoolHolidayDetails.push(dateStr);
                teacherSummary.completedChecklokCount++;
              } else if (allValidReasonsFromSheet.includes(ketManualLower)) {
                teacherSummary.otherValidReasonDetails.push(`${dateStr} : ${ketManual}`);
                teacherSummary.completedChecklokCount++;
              } else { // Keterangan manual ada tapi bukan alasan valid / bukan libur sekolah
                if (isBaseWorkingDay && currentDate < today) { // Dianggap alpa jika hari kerja telah berlalu
                  teacherSummary.absentDetails.push(dateStr);
                }
              }
            } else if (jamMasuk && jamPulang) {
              if (isBaseWorkingDay) { // Hanya dihitung hadir jika memang hari kerja
                teacherSummary.presentDetails.push(dateStr);
                teacherSummary.completedChecklokCount++;
              }
            } else if (jamMasuk || jamPulang) { // Salah satu jam terisi
              if (isBaseWorkingDay) {
                const missingPart = jamMasuk ? "Jam Pulang Kosong" : "Jam Masuk Kosong";
                teacherSummary.incompleteDetails.push(`${dateStr} : ${missingPart}`);
              }
            } else { // Tidak ada jam, tidak ada keterangan
              if (isBaseWorkingDay && currentDate < today) {
                teacherSummary.absentDetails.push(dateStr);
              }
            }
            entryProcessed = true;
            break; 
          }
        }
        
        if (!entryProcessed && isBaseWorkingDay && currentDate < today) {
          teacherSummary.absentDetails.push(dateStr);
        }
      } // end loop days

      if (totalWorkingDaysInMonth > 0) {
        teacherSummary.attendancePercentage = parseFloat(((teacherSummary.completedChecklokCount / totalWorkingDaysInMonth) * 100).toFixed(2));
      }
      allTeachersSummary.push(teacherSummary);
    } // end loop teachers

    return {
      success: true,
      monthYear: monthYear,
      totalWorkingDaysInMonth: totalWorkingDaysInMonth,
      effectiveWorkingDaysPassed: effectiveWorkingDaysPassed,
      allTeachersSummary: allTeachersSummary
    };

  } catch (e) {
    Logger.log(`Error in getOverallMonthlySummaryForAllTeachers (month: ${monthYear}): ${e.toString()}\nStack: ${e.stack}`);
    // Log to activity log if possible, or handle error display
    logUserActivity(Session.getActiveUser().getEmail(), actingUserRole, "GET_OVERALL_SUMMARY_ERROR", monthYear, e.message, "ERROR");
    return { success: false, error: `Gagal mengambil ringkasan keseluruhan: ${e.message}` };
  }
}

/**
 * Guru mengajukan permintaan perubahan username.
 * @param {string} currentUsername Username guru saat ini.
 * @param {string} requestedUsername Username baru yang diinginkan.
 * @param {string} teacherName Nama asli guru.
 * @param {string} actorRole Peran pengguna yang mengajukan (seharusnya 'user').
 * @return {object} Hasil operasi {success: boolean, message/error: string}.
 */
function submitUsernameChangeRequest(currentUsername, requestedUsername, teacherName, actorRole) {
  try {
    if (!currentUsername || !requestedUsername || !teacherName) {
      return { success: false, error: "Informasi tidak lengkap (username saat ini, username baru, nama guru)." };
    }
    if (requestedUsername.trim().length < 4) {
         return { success: false, error: "Username baru minimal 4 karakter."};
    }
    if (currentUsername.toLowerCase() === requestedUsername.trim().toLowerCase()) {
        return { success: false, error: "Username baru tidak boleh sama dengan username saat ini." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    const requestsSheet = ensureSheet(USERNAME_CHANGE_REQUESTS_SHEET_NAME, [
      "RequestID", "CurrentUsername", "RequestedUsername", "TeacherName", 
      "RequestDate", "Status", "Notes", "ProcessedBy", "ProcessedDate"
    ]);

    // Cek apakah username baru sudah digunakan di Users sheet
    const usersData = usersSheet.getDataRange().getValues();
    const usernamesInUsers = usersData.slice(1).map(row => String(row[0]).trim().toLowerCase());
    if (usernamesInUsers.includes(requestedUsername.trim().toLowerCase())) {
      logUserActivity(currentUsername, actorRole, "SUBMIT_USERNAME_CHANGE_FAIL", requestedUsername, `Username baru sudah ada di Users`, "FAIL");
      return { success: false, error: `Username '${requestedUsername}' sudah digunakan. Pilih username lain.` };
    }

    // Cek apakah username baru sudah ada di pengajuan PENDING atau APPROVED LAINNYA
    const requestsData = requestsSheet.getDataRange().getValues();
    for (let i = 1; i < requestsData.length; i++) {
        const reqUser = String(requestsData[i][2]).trim().toLowerCase(); // RequestedUsername
        const reqStatus = String(requestsData[i][5]).trim().toLowerCase(); // Status
        if (reqUser === requestedUsername.trim().toLowerCase() && (reqStatus === "pending" || reqStatus === "approved")) {
            logUserActivity(currentUsername, actorRole, "SUBMIT_USERNAME_CHANGE_FAIL", requestedUsername, `Username baru sudah ada di pengajuan lain (ID: ${requestsData[i][0]})`, "FAIL");
            return { success: false, error: `Username '${requestedUsername}' sudah diajukan atau digunakan. Pilih username lain.` };
        }
    }

    // Cek apakah pengguna sudah memiliki pengajuan PENDING
    for (let i = 1; i < requestsData.length; i++) {
        const reqCurrentUsername = String(requestsData[i][1]).trim().toLowerCase(); // CurrentUsername
        const reqStatus = String(requestsData[i][5]).trim().toLowerCase(); // Status
        if (reqCurrentUsername === currentUsername.toLowerCase() && reqStatus === "pending") {
            logUserActivity(currentUsername, actorRole, "SUBMIT_USERNAME_CHANGE_FAIL", requestedUsername, `Sudah ada pengajuan pending (ID: ${requestsData[i][0]})`, "FAIL");
            return { success: false, error: "Anda sudah memiliki pengajuan perubahan username yang sedang diproses." };
        }
    }

    const requestId = Utilities.getUuid();
    const requestDate = new Date();
    requestsSheet.appendRow([
      requestId, currentUsername, requestedUsername.trim(), teacherName,
      requestDate, "pending", "", "", ""
    ]);

    logUserActivity(currentUsername, actorRole, "SUBMIT_USERNAME_CHANGE_SUCCESS", requestedUsername, `Dari: ${currentUsername}`, "SUCCESS");
    return { success: true, message: "Pengajuan perubahan username berhasil dikirim. Mohon tunggu persetujuan Admin." };

  } catch (e) {
    Logger.log(`Error in submitUsernameChangeRequest: ${e.toString()}`);
    logUserActivity(currentUsername || "N/A", actorRole || "N/A", "SUBMIT_USERNAME_CHANGE_ERROR", requestedUsername || "N/A", e.message, "ERROR");
    return { success: false, error: `Gagal mengirim pengajuan: ${e.message}` };
  }
}

/**
 * Mengambil daftar pengajuan perubahan username yang masih pending.
 * @param {string} adminUsername Username admin yang melakukan aksi.
 * @param {string} adminRole Peran admin.
 * @return {object} Objek berisi {success: boolean, requests?: object[], error?: string}.
 */
function getPendingUsernameChangeRequests(adminUsername, adminRole) {
  if (adminRole !== ROLE_ADMIN && adminRole !== ROLE_SUPERADMIN) {
    return { success: false, error: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const requestsSheet = ss.getSheetByName(USERNAME_CHANGE_REQUESTS_SHEET_NAME);
    if (!requestsSheet || requestsSheet.getLastRow() < 2) {
      return { success: true, requests: [] };
    }

    const data = requestsSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim());
    const pendingRequests = [];

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const status = String(row[headers.indexOf("Status")]).trim().toLowerCase();
      if (status === "pending") {
        pendingRequests.push({
          requestID: String(row[headers.indexOf("RequestID")]),
          currentUsername: String(row[headers.indexOf("CurrentUsername")]),
          requestedUsername: String(row[headers.indexOf("RequestedUsername")]),
          teacherName: String(row[headers.indexOf("TeacherName")]),
          requestDate: row[headers.indexOf("RequestDate")] instanceof Date ? Utilities.formatDate(new Date(row[headers.indexOf("RequestDate")]), Session.getScriptTimeZone(), "dd/MM/yyyy HH:mm") : String(row[headers.indexOf("RequestDate")])
        });
      }
    }
    return { success: true, requests: pendingRequests };
  } catch (e) {
    Logger.log(`Error in getPendingUsernameChangeRequests: ${e.toString()}`);
    return { success: false, error: `Gagal mengambil daftar pengajuan: ${e.message}` };
  }
}

/**
 * Admin memproses pengajuan perubahan username (setujui/tolak).
 * @param {string} requestID ID pengajuan yang akan diproses.
 * @param {string} action "approve" atau "reject".
 * @param {string} adminUsername Username admin yang memproses.
 * @param {string} adminRole Peran admin yang memproses.
 * @param {string} [notes=""] Catatan dari admin (opsional, misal alasan penolakan).
 * @return {object} Hasil operasi {success: boolean, message/error: string}.
 */
function processUsernameChangeRequest(requestID, action, adminUsername, adminRole, notes = "") {
  if (adminRole !== ROLE_ADMIN && adminRole !== ROLE_SUPERADMIN) {
    return { success: false, error: "Akses ditolak." };
  }
  action = String(action).toLowerCase();
  if (action !== "approve" && action !== "reject") {
    return { success: false, error: "Aksi tidak valid." };
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const requestsSheet = ss.getSheetByName(USERNAME_CHANGE_REQUESTS_SHEET_NAME);
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);

    if (!requestsSheet || !usersSheet) {
      return { success: false, error: "Sheet penting tidak ditemukan." };
    }

    const requestsData = requestsSheet.getDataRange().getValues();
    const reqHeaders = requestsData[0].map(h => String(h).trim());
    let requestRowIndex = -1;
    let requestDetails = {};

    for (let i = 1; i < requestsData.length; i++) {
      if (String(requestsData[i][reqHeaders.indexOf("RequestID")]) === requestID) {
        requestRowIndex = i + 1;
        requestDetails = {
          currentUsername: String(requestsData[i][reqHeaders.indexOf("CurrentUsername")]),
          requestedUsername: String(requestsData[i][reqHeaders.indexOf("RequestedUsername")]),
          status: String(requestsData[i][reqHeaders.indexOf("Status")]).toLowerCase()
        };
        break;
      }
    }

    if (requestRowIndex === -1) {
      return { success: false, error: "Pengajuan tidak ditemukan." };
    }
    if (requestDetails.status !== "pending") {
      return { success: false, error: `Pengajuan ini sudah ${requestDetails.status}.` };
    }

    const processedDate = new Date();
    let message = "";

    if (action === "approve") {
      // Cek sekali lagi apakah username baru sudah digunakan
      const usersData = usersSheet.getDataRange().getValues();
      const usernamesInUsers = usersData.slice(1).map(row => String(row[0]).trim().toLowerCase());
      if (usernamesInUsers.includes(requestDetails.requestedUsername.toLowerCase())) {
        // Otomatis tolak jika sudah diambil
        requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("Status") + 1).setValue("rejected");
        requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("Notes") + 1).setValue("Ditolak otomatis: Username baru sudah digunakan saat proses approval.");
        requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("ProcessedBy") + 1).setValue(adminUsername);
        requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("ProcessedDate") + 1).setValue(processedDate);
        logUserActivity(adminUsername, adminRole, "REJECT_USERNAME_CHANGE_AUTO", requestDetails.requestedUsername, `ReqID: ${requestID}, Dari: ${requestDetails.currentUsername}, Alasan: Username sudah digunakan`, "SUCCESS");
        return { success: false, error: `Gagal menyetujui: Username '${requestDetails.requestedUsername}' sudah digunakan. Pengajuan ditolak otomatis.` };
      }

      // Update username di Users sheet
      let userUpdatedInUsersSheet = false;
      const userHeaders = usersData[0].map(h=>String(h).trim().toLowerCase());
      const userUsernameColIdx = userHeaders.indexOf("username");

      for (let i = 1; i < usersData.length; i++) {
        if (String(usersData[i][userUsernameColIdx]).trim().toLowerCase() === requestDetails.currentUsername.toLowerCase()) {
          usersSheet.getRange(i + 1, userUsernameColIdx + 1).setValue(requestDetails.requestedUsername);
          userUpdatedInUsersSheet = true;
          break;
        }
      }

      if (!userUpdatedInUsersSheet) {
         logUserActivity(adminUsername, adminRole, "APPROVE_USERNAME_CHANGE_FAIL", requestDetails.requestedUsername, `ReqID: <span class="math-inline">\{requestID\}, User lama '</span>{requestDetails.currentUsername}' tidak ditemukan di Users sheet`, "FAIL");
        return { success: false, error: `Gagal update: Pengguna '${requestDetails.currentUsername}' tidak ditemukan di sheet Users.` };
      }

      requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("Status") + 1).setValue("approved");
      message = `Pengajuan username untuk '${requestDetails.currentUsername}' ke '${requestDetails.requestedUsername}' telah disetujui.`;
      logUserActivity(adminUsername, adminRole, "APPROVE_USERNAME_CHANGE_SUCCESS", requestDetails.requestedUsername, `ReqID: ${requestID}, Dari: ${requestDetails.currentUsername}, Catatan: ${notes}`, "SUCCESS");

    } else { // action === "reject"
      requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("Status") + 1).setValue("rejected");
      message = `Pengajuan username untuk '${requestDetails.currentUsername}' ke '${requestDetails.requestedUsername}' telah ditolak.`;
      logUserActivity(adminUsername, adminRole, "REJECT_USERNAME_CHANGE_SUCCESS", requestDetails.requestedUsername, `ReqID: ${requestID}, Dari: ${requestDetails.currentUsername}, Catatan: ${notes}`, "SUCCESS");
    }

    requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("Notes") + 1).setValue(notes);
    requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("ProcessedBy") + 1).setValue(adminUsername);
    requestsSheet.getRange(requestRowIndex, reqHeaders.indexOf("ProcessedDate") + 1).setValue(processedDate);

    SpreadsheetApp.flush();
    return { success: true, message: message };

  } catch (e) {
    Logger.log(`Error in processUsernameChangeRequest (ID: ${requestID}, Action: ${action}): ${e.toString()}`);
    logUserActivity(adminUsername, adminRole, "PROCESS_USERNAME_CHANGE_ERROR", requestID, `Aksi: ${action}, Error: ${e.message}`, "ERROR");
    return { success: false, error: `Gagal memproses pengajuan: ${e.message}` };
  }
}

function checkUserPendingUsernameRequest(username) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const requestsSheet = ss.getSheetByName(USERNAME_CHANGE_REQUESTS_SHEET_NAME);
    if (!requestsSheet || requestsSheet.getLastRow() < 2) {
      return { success: true, hasPendingRequest: false };
    }
    const data = requestsSheet.getDataRange().getValues();
    const headers = data[0].map(h => String(h).trim());
    const currentUsernameCol = headers.indexOf("CurrentUsername");
    const statusCol = headers.indexOf("Status");

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][currentUsernameCol]).trim().toLowerCase() === username.toLowerCase() &&
          String(data[i][statusCol]).trim().toLowerCase() === "pending") {
        return { success: true, hasPendingRequest: true };
      }
    }
    return { success: true, hasPendingRequest: false };
  } catch (e) {
    Logger.log("Error checking pending username request for " + username + ": " + e.toString());
    return { success: false, error: "Gagal memeriksa status pengajuan."};
  }
}

// Di dalam file code.gs.html

// Pastikan variabel CONFIG_SHEET_NAME sudah didefinisikan di atas, misal:
// const CONFIG_SHEET_NAME = "Setting"; // Atau "MasterConfig" atau nama sheet config Anda

/**
 * Mengambil nilai konfigurasi dari sheet Setting/MasterConfig.
 * @param {Array<string>} keysArray Array dari nama kunci konfigurasi yang ingin diambil.
 * @return {Object} Objek yang berisi pasangan key-value dari konfigurasi, plus {success: true}.
 * Atau {success: false, error: string} jika gagal.
 */
function getConfigValues(keysArray) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const configSheet = ss.getSheetByName(SETTING_SHEET_NAME); // Menggunakan SETTING_SHEET_NAME
    if (!configSheet) {
      return { success: false, error: `Sheet konfigurasi '${SETTING_SHEET_NAME}' tidak ditemukan.`};
    }
    const data = configSheet.getDataRange().getValues();
    const configs = {};
    
    // Asumsi format di Setting: Kolom A = Nama Setting, Kolom B = Value
    // Khusus untuk A1 (adminDefinedMinMonthYear), kita akan treat sebagai CEKLOK_START_DATE
    if (keysArray.includes('CEKLOK_START_DATE')) {
        const startDateVal = data[0][0]; // Ambil dari A1
        if (startDateVal && /^\d{2}\/\d{4}$/.test(String(startDateVal))) {
            configs['CEKLOK_START_DATE'] = String(startDateVal);
        } else {
            Logger.log("CEKLOK_START_DATE (dari A1) tidak valid atau kosong.");
            // Fallback jika A1 tidak valid, bisa diatur di sini atau biarkan error di getYearlyAttendanceData
        }
    }
    // Untuk setting lain jika ada (misal MIN_CEKLOK_YEAR jika disimpan terpisah)
    // Untuk MIN_CEKLOK_YEAR, kita akan ambil tahunnya dari CEKLOK_START_DATE saja.

    configs.success = true;
    return configs;
  } catch (e) {
    Logger.log(`Error in getConfigValues: ${e}`);
    return { success: false, error: `Gagal mengambil konfigurasi: ${e.message}` };
  }
}


function getYearlyAttendanceData(teacherName, year) {
  try {
    if (!teacherName || !year) {
      return { success: false, error: "Nama guru dan tahun harus diisi." };
    }

    const configs = getConfigValues(['CEKLOK_START_DATE']); // Ambil config yang dibutuhkan
    if (!configs.success) return configs;
    
    const ceklokStartDateStr = configs.CEKLOK_START_DATE; 
    if (!ceklokStartDateStr || !/^\d{2}\/\d{4}$/.test(ceklokStartDateStr)) {
      return { success: false, error: "Format CEKLOK_START_DATE (dari Setting A1) tidak valid atau tidak ditemukan. Harusnya MM/YYYY." };
    }
    const [startMonthStr, startYearStr] = ceklokStartDateStr.split('/');
    const ceklokStartDateSetting = {
      month: parseInt(startMonthStr, 10),
      year: parseInt(startYearStr, 10)
    };

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ceklokManualSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    const kalenderSheet = ss.getSheetByName(KALENDER_SHEET_NAME);
    const opsiKetLiburSheet = ss.getSheetByName(OPSIKETLIBUR_SHEET_NAME);

    if (!ceklokManualSheet || !kalenderSheet || !opsiKetLiburSheet) {
      return { success: false, error: "Sheet Ceklok_Manual, Kalender_Pendidikan, atau OpsiKetLibur tidak ditemukan." };
    }

    const allCeklokData = ceklokManualSheet.getDataRange().getValues();
    const ceklokHeaders = allCeklokData[0].map(h => String(h).trim().toLowerCase());
    const idxNama = ceklokHeaders.indexOf("nama_guru");
    const idxTanggalCeklok = ceklokHeaders.indexOf("tanggal");
    const idxMasuk = ceklokHeaders.indexOf("jam_masuk");
    const idxPulang = ceklokHeaders.indexOf("jam_pulang");
    const idxKetManual = ceklokHeaders.indexOf("ket_libur_manual");

    if ([idxNama, idxTanggalCeklok, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap." };
    }
    
    const teacherCeklokEntries = {};
    for (let i = 1; i < allCeklokData.length; i++) {
        const row = allCeklokData[i];
        if (String(row[idxNama]).trim() === teacherName && row[idxTanggalCeklok] instanceof Date) {
            const dateKey = Utilities.formatDate(new Date(row[idxTanggalCeklok]), Session.getScriptTimeZone(), "dd/MM/yyyy");
            teacherCeklokEntries[dateKey] = {
                jamMasuk: String(row[idxMasuk] || "").trim(),
                jamPulang: String(row[idxPulang] || "").trim(),
                ketManual: String(row[idxKetManual] || "").trim()
            };
        }
    }

    const kalenderLiburMap = {};
    if (kalenderSheet.getLastRow() > 1) {
      const kalenderData = kalenderSheet.getRange(2, 1, kalenderSheet.getLastRow() - 1, 2).getDisplayValues();
      kalenderData.forEach(row => {
        if (row[0] && String(row[0]).trim() !== "") {
          kalenderLiburMap[String(row[0]).trim()] = String(row[1]).trim() || "Hari Libur Nasional";
        }
      });
    }

    const opsiKetLiburList = []; 
     if (opsiKetLiburSheet.getLastRow() > 1) {
        opsiKetLiburSheet.getRange(2, 1, opsiKetLiburSheet.getLastRow() - 1, 1).getValues().flat().forEach(item => {
            if(item && String(item).trim()) opsiKetLiburList.push(String(item).trim().toLowerCase());
        });
    }
    const nonWorkingManualReasons = opsiKetLiburList.filter(
        reason => reason.includes("hari libur sekolah") || reason.includes("libur sekolah")
    );
    const excusedAbsenceReasons = opsiKetLiburList.filter(
        reason => !nonWorkingManualReasons.includes(reason)
    );

    const yearData = {};
    const monthNames = ["Januari", "Februari", "Maret", "April", "Mei", "Juni", 
                        "Juli", "Agustus", "September", "Oktober", "November", "Desember"];
    const today = new Date();
    today.setHours(0,0,0,0);
    const currentEvalYear = today.getFullYear();
    const currentEvalMonth = today.getMonth() + 1; 
    const namaHariIndonesia = ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"];

    for (let monthIdx = 0; monthIdx < 12; monthIdx++) {
      const monthName = monthNames[monthIdx];
      yearData[monthName] = [];
      const daysInMonth = new Date(year, monthIdx + 1, 0).getDate();

      for (let day = 1; day <= daysInMonth; day++) {
        const dateObj = new Date(year, monthIdx, day);
        dateObj.setHours(0,0,0,0);
        const dateStr_ddMMyyyy = Utilities.formatDate(dateObj, Session.getScriptTimeZone(), "dd/MM/yyyy");
        
        let status = "white"; 
        let detailMessage = "Di Luar Periode Aktif / Masa Depan";
        let isNonWorkingScheduled = false;
        const targetMonthInLoop = monthIdx + 1;

        if (year < ceklokStartDateSetting.year || (year === ceklokStartDateSetting.year && targetMonthInLoop < ceklokStartDateSetting.month)) {
          status = "white";
          detailMessage = "Sebelum periode ceklok aktif";
          isNonWorkingScheduled = true;
        } else if (year > currentEvalYear || (year === currentEvalYear && targetMonthInLoop > currentEvalMonth)) {
          status = "white";
          detailMessage = "Periode masa depan";
          isNonWorkingScheduled = true;
        } else {
          const dayOfWeek = dateObj.getDay();
          const ceklokEntry = teacherCeklokEntries[dateStr_ddMMyyyy];
          const jamMasuk = ceklokEntry ? ceklokEntry.jamMasuk : "";
          const jamPulang = ceklokEntry ? ceklokEntry.jamPulang : "";
          const ketManualOriginal = ceklokEntry ? ceklokEntry.ketManual : "";
          const ketManualLower = ketManualOriginal.toLowerCase();

          if (dayOfWeek === 0) { // Minggu -> jadi PUTIH
            status = "white";
            detailMessage = "Hari Minggu"; // Pesan detail untuk Minggu (meskipun tidak diklik)
            isNonWorkingScheduled = true;
          } else if (dayOfWeek === 7) { // Sabtu -> tetap BIRU
            status = "blue";
            detailMessage = "Hari Libur: Sabtu";
            isNonWorkingScheduled = true;
          } else if (kalenderLiburMap[dateStr_ddMMyyyy]) { // Libur Nasional/Kalender
            status = "blue";
            detailMessage = `Hari Libur: ${kalenderLiburMap[dateStr_ddMMyyyy]}`;
            isNonWorkingScheduled = true;
          } else if (ketManualLower && nonWorkingManualReasons.includes(ketManualLower)) { // Manual "Libur Sekolah"
            status = "blue";
            detailMessage = `Keterangan: ${ketManualOriginal}`;
            isNonWorkingScheduled = true;
          } else if (ketManualLower && excusedAbsenceReasons.includes(ketManualLower)) { // Sakit, Izin, dll.
            status = "blue"; 
            detailMessage = `Keterangan: ${ketManualOriginal}`;
            isNonWorkingScheduled = true; 
          } else if (dateObj <= today) { 
            if (jamMasuk && jamPulang) {
              status = "green";
              detailMessage = "Hadir (Jam Masuk & Pulang Terisi)";
            } else if (jamMasuk && !jamPulang) {
              status = "yellow";
              detailMessage = "Jam Pulang Kosong";
            } else if (!jamMasuk && jamPulang) {
              status = "yellow";
              detailMessage = "Jam Masuk Kosong";
            } else { 
              status = "red"; 
              detailMessage = "Alpa (Tidak Ada Data)";
            }
          } else { 
             status = "white"; 
             detailMessage = "Jadwal Mendatang";
          }
        }
        yearData[monthName].push({ 
            date: day, 
            status: status, 
            isNonWorkingScheduled: isNonWorkingScheduled,
            detailMessage: detailMessage 
        });
      }
    }
    return { success: true, yearData: yearData };
  } catch (e) {
    Logger.log(`Error in getYearlyAttendanceData (teacher: ${teacherName}, year: ${year}): ${e.toString()}\nStack: ${e.stack}`);
    return { success: false, error: `Gagal memproses data kehadiran tahunan: ${e.message}` };
  }
}

// Letakkan ini di dalam file .gs atau di dalam tag <script> di code.gs.html

// Pastikan konstanta ini sudah didefinisikan secara global di skrip Anda
// const ROLE_SUPERADMIN = "superadmin"; // Contoh, sesuaikan dengan definisi di proyek Anda
// const USERS_SHEET_NAME = "Users"; // Pastikan ini nama sheet pengguna Anda
// const ACTIVITY_LOG_SHEET_NAME = "Activity_Log"; // Contoh, sesuaikan

/**
 * Mereset (menghapus) log aktivitas berdasarkan periode waktu yang dipilih.
 * Hanya bisa diakses oleh Superadmin.
 *
 * @param {string} timeframeIdentifier String yang mengidentifikasi periode penghapusan.
 * @return {object} Objek hasil operasi {success: boolean, message/error: string}.
 */
function resetActivityLog(timeframeIdentifier) {
  let lock; // Deklarasikan lock di sini agar bisa diakses di finally
  let currentUser = { email: '', role: '', username: '' }; // Inisialisasi objek currentUser

  try {
    lock = LockService.getScriptLock();

    if (!lock) {
      Logger.log("resetActivityLog: LockService.getScriptLock() gagal mengembalikan objek lock.");
      return { success: false, error: "Gagal menginisialisasi mekanisme penguncian internal." };
    }

    if (!lock.tryLock(30000)) { // Coba kunci selama 30 detik
      Logger.log("resetActivityLog: Gagal mendapatkan lock (timeout atau sudah terkunci oleh proses lain).");
      return { success: false, error: "Server sedang sibuk atau ada proses lain yang berjalan. Coba beberapa saat lagi." };
    }
    Logger.log(`resetActivityLog: Lock diperoleh. Memproses timeframe: ${timeframeIdentifier}`);

    // Ambil informasi pengguna yang sedang aktif
    const activeUserEmail = Session.getActiveUser().getEmail();
    currentUser.email = activeUserEmail; // Simpan email aktif

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheetForRole = ss.getSheetByName(USERS_SHEET_NAME); 
    if (usersSheetForRole && activeUserEmail) {
        const usersData = usersSheetForRole.getDataRange().getValues();
        const userHeaders = usersData[0].map(h => String(h).trim().toLowerCase());
        const usernameColIdx = userHeaders.indexOf("username");
        const roleColIdx = userHeaders.indexOf("role");
        const googleEmailColIdx = userHeaders.indexOf("googleemail"); 
        const primaryEmailColIdx = userHeaders.indexOf("primaryemail");

        let foundUserForRole = false;
        for (let i = 1; i < usersData.length; i++) {
            const sheetUsername = usersData[i][usernameColIdx] ? String(usersData[i][usernameColIdx]).trim().toLowerCase() : "";
            const sheetGoogleEmail = (googleEmailColIdx > -1 && usersData[i][googleEmailColIdx]) ? String(usersData[i][googleEmailColIdx]).trim().toLowerCase() : "";
            const sheetPrimaryEmail = (primaryEmailColIdx > -1 && usersData[i][primaryEmailColIdx]) ? String(usersData[i][primaryEmailColIdx]).trim().toLowerCase() : "";

            if ((sheetGoogleEmail && sheetGoogleEmail === activeUserEmail.toLowerCase()) ||
                (sheetPrimaryEmail && sheetPrimaryEmail === activeUserEmail.toLowerCase()) ||
                sheetUsername === activeUserEmail.toLowerCase()) {
                currentUser.role = String(usersData[i][roleColIdx]).trim();
                currentUser.username = sheetUsername; // Simpan username asli pengguna
                foundUserForRole = true;
                break;
            }
        }
        if (!foundUserForRole) {
             Logger.log(`resetActivityLog: Tidak dapat menemukan peran untuk pengguna aktif ${activeUserEmail}. Menganggap peran tidak memadai.`);
             // Jika peran tidak ditemukan, anggap bukan superadmin untuk keamanan
             currentUser.role = "unknown"; 
        }
        Logger.log(`DEBUG resetActivityLog - Email Aktif: ${activeUserEmail}, Username Ditemukan dari Sheet: '${currentUser.username}', Peran Ditemukan dari Sheet: '${currentUser.role}', Konstanta ROLE_SUPERADMIN: '${ROLE_SUPERADMIN}'`);
    } else {
        Logger.log("resetActivityLog: Sheet Users atau email pengguna aktif tidak tersedia untuk verifikasi peran.");
        currentUser.role = "unknown"; // Default jika tidak bisa verifikasi
        Logger.log(`DEBUG resetActivityLog (Sheet/Email tidak ada) - Email Aktif: ${activeUserEmail}, Peran Ditemukan: '${currentUser.role}', Konstanta ROLE_SUPERADMIN: '${ROLE_SUPERADMIN}'`);
    }

    if (currentUser.role !== ROLE_SUPERADMIN) {
      Logger.log(`resetActivityLog: Akses ditolak. Pengguna aktual: ${currentUser.email}, Peran aktual terdeteksi: '${currentUser.role}', Peran yang diharapkan untuk akses: '${ROLE_SUPERADMIN}'`);
      return { success: false, error: "Akses ditolak. Hanya Superadmin yang dapat mereset log." };
    }

    const logSheet = ss.getSheetByName(ACTIVITY_LOG_SHEET_NAME);
    if (!logSheet) {
      Logger.log(`resetActivityLog: Sheet log '${ACTIVITY_LOG_SHEET_NAME}' tidak ditemukan.`);
      return { success: false, error: `Sheet log aktivitas dengan nama '${ACTIVITY_LOG_SHEET_NAME}' tidak ditemukan.` };
    }

    const dataRange = logSheet.getDataRange();
    const logs = dataRange.getValues();
    
    if (logs.length <= 1) { 
      return { success: true, message: "Tidak ada log aktivitas untuk direset." };
    }

    const header = logs[0]; 
    const timestampColIndex = 0; // Kolom pertama (indeks 0) adalah 'Waktu' atau Timestamp

    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()); 
    let deletePredicate; 

    Logger.log(`Menentukan predikat hapus untuk: ${timeframeIdentifier}`);

    switch (timeframeIdentifier) {
      case 'today':
        deletePredicate = (logTimestamp) => {
          const d = new Date(logTimestamp);
          return d.getFullYear() === todayStart.getFullYear() &&
                 d.getMonth() === todayStart.getMonth() &&
                 d.getDate() === todayStart.getDate();
        };
        break;
      case 'yesterday':
        const yesterdayStart = new Date(todayStart);
        yesterdayStart.setDate(todayStart.getDate() - 1);
        deletePredicate = (logTimestamp) => {
          const d = new Date(logTimestamp);
          return d.getFullYear() === yesterdayStart.getFullYear() &&
                 d.getMonth() === yesterdayStart.getMonth() &&
                 d.getDate() === yesterdayStart.getDate();
        };
        break;
      default: 
        let cutoffDateLimit; 
        if (timeframeIdentifier === 'all') {
            deletePredicate = () => true; 
        } else {
            cutoffDateLimit = new Date(todayStart); 
            if (timeframeIdentifier === 'older_than_3_days') cutoffDateLimit.setDate(todayStart.getDate() - (3 - 1));
            else if (timeframeIdentifier === 'older_than_5_days') cutoffDateLimit.setDate(todayStart.getDate() - (5 - 1));
            else if (timeframeIdentifier === 'older_than_1_week') cutoffDateLimit.setDate(todayStart.getDate() - (7 - 1));
            else if (timeframeIdentifier === 'older_than_3_weeks') cutoffDateLimit.setDate(todayStart.getDate() - (21 - 1));
            else if (timeframeIdentifier === 'older_than_1_month') { cutoffDateLimit.setMonth(todayStart.getMonth() - 1); cutoffDateLimit.setDate(cutoffDateLimit.getDate() + 1); }
            else if (timeframeIdentifier === 'older_than_3_months') { cutoffDateLimit.setMonth(todayStart.getMonth() - 3); cutoffDateLimit.setDate(cutoffDateLimit.getDate() + 1); }
            else if (timeframeIdentifier === 'older_than_6_months') { cutoffDateLimit.setMonth(todayStart.getMonth() - 6); cutoffDateLimit.setDate(cutoffDateLimit.getDate() + 1); }
            else if (timeframeIdentifier === 'older_than_9_months') { cutoffDateLimit.setMonth(todayStart.getMonth() - 9); cutoffDateLimit.setDate(cutoffDateLimit.getDate() + 1); }
            else if (timeframeIdentifier === 'older_than_1_year') { cutoffDateLimit.setFullYear(todayStart.getFullYear() - 1); cutoffDateLimit.setDate(cutoffDateLimit.getDate() + 1); }
            else {
                Logger.log(`resetActivityLog: Periode reset tidak valid: ${timeframeIdentifier}`);
                return { success: false, error: "Periode reset tidak valid." };
            }
            Logger.log(`resetActivityLog: Cutoff date limit untuk '${timeframeIdentifier}' adalah ${cutoffDateLimit.toISOString()}`);
            deletePredicate = (logTimestamp) => new Date(logTimestamp) < cutoffDateLimit;
        }
    }

    let rowsToDeleteIndices = [];
    for (let i = 1; i < logs.length; i++) { // Mulai dari 1 untuk melewati header
      const logTimestampValue = logs[i][timestampColIndex];
      if (!logTimestampValue) { 
          Logger.log(`resetActivityLog: Timestamp kosong di baris sheet ${i + 1}`);
          continue;
      }
      let logTimestamp;
      if (logTimestampValue instanceof Date) {
          logTimestamp = logTimestampValue;
      } else {
          logTimestamp = new Date(logTimestampValue); // Coba parsing jika string
      }
      
      if (isNaN(logTimestamp.getTime())) {
        Logger.log(`resetActivityLog: Format tanggal tidak valid di log baris sheet ${i + 1}. Nilai: '${logTimestampValue}'`);
        continue; 
      }
      if (deletePredicate(logTimestamp)) {
        rowsToDeleteIndices.push(i + 1); 
      }
    }

    if (rowsToDeleteIndices.length === 0) {
      Logger.log("resetActivityLog: Tidak ada log yang cocok dengan kriteria untuk dihapus.");
      return { success: true, message: "Tidak ada log yang cocok dengan kriteria untuk dihapus." };
    }

    Logger.log(`resetActivityLog: Akan menghapus ${rowsToDeleteIndices.length} baris. Indeks: ${JSON.stringify(rowsToDeleteIndices)}`);
    rowsToDeleteIndices.sort((a, b) => b - a); // Hapus dari bawah ke atas
    for (const rowIndex of rowsToDeleteIndices) {
      logSheet.deleteRow(rowIndex);
    }
    
    if (typeof logUserActivity === "function") {
        const actorToLog = currentUser.username || currentUser.email; // Gunakan username jika ada, fallback ke email
        logUserActivity(actorToLog, ROLE_SUPERADMIN, "RESET_LOG_AKTIVITAS", `Periode: ${timeframeIdentifier}`, `Jumlah log dihapus: ${rowsToDeleteIndices.length}`, "SUCCESS");
    }
    Logger.log(`resetActivityLog: Sebanyak ${rowsToDeleteIndices.length} log aktivitas telah dihapus untuk periode '${timeframeIdentifier}'.`);
    return { success: true, message: `Sebanyak ${rowsToDeleteIndices.length} log aktivitas telah dihapus.` };

  } catch (e) {
    Logger.log("Error di resetActivityLog: " + e.toString() + "\nStack: " + e.stack);
     if (typeof logUserActivity === "function") {
        const actorToLog = (currentUser && currentUser.username) ? currentUser.username : ((currentUser && currentUser.email) ? currentUser.email : "SYSTEM_ERROR_USER_UNDEFINED");
        const actorRoleToLog = (currentUser && currentUser.role) ? currentUser.role : "N/A";
        logUserActivity(actorToLog, actorRoleToLog, "RESET_LOG_ERROR", timeframeIdentifier || "N/A", e.message, "ERROR");
    }
    return { success: false, error: "Terjadi kesalahan internal server saat mereset log: " + e.message };
  } finally {
    if (lock && lock.hasLock()) { 
      lock.releaseLock();
      Logger.log("resetActivityLog: Lock dilepas.");
    } else if (lock) { 
        Logger.log("resetActivityLog: Lock diinisialisasi tapi tidak dipegang pada blok finally (mungkin tryLock gagal atau lock tidak valid).");
    } else { 
        Logger.log("resetActivityLog: Objek lock tidak diinisialisasi pada blok finally.");
    }
  }
}

// Sisipkan fungsi ini di dalam file Kode.gs.html

/**
 * (VERSI 2)
 * Mengimpor data dari file Excel dan memperbarui sheet Ceklok_Manual.
 * Data dicocokkan berdasarkan Nama Guru dan Tanggal.
 * - Menyertakan kolom keterangan/alasan.
 * - Memperbaiki format tanggal menjadi date-only.
 * - Memaksa format jam menjadi teks untuk mencegah salah format.
 *
 * @param {string} teacherName Nama guru yang datanya akan diimpor.
 * @param {Array<Array<string>>} excelData Array 2D berisi data dari Excel.
 * @return {object} Hasil operasi {success: boolean, message/error: string}.
 */
function importFromExcel(teacherName, excelData) {
  if (!teacherName) {
    return { success: false, error: "Nama guru harus dipilih." };
  }
  if (!excelData || excelData.length < 2) {
    return { success: false, error: "Data Excel tidak valid atau kosong." };
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ceklokSheet = ss.getSheetByName(CEKLOK_MANUAL_SHEET_NAME);
    if (!ceklokSheet) {
      return { success: false, error: `Sheet '${CEKLOK_MANUAL_SHEET_NAME}' tidak ditemukan.` };
    }

    const allCeklokData = ceklokSheet.getDataRange().getValues();
    const ceklokHeaders = allCeklokData[0].map(h => String(h).trim().toLowerCase());
    const idxNama = ceklokHeaders.indexOf("nama_guru");
    const idxTanggal = ceklokHeaders.indexOf("tanggal");
    const idxMasuk = ceklokHeaders.indexOf("jam_masuk");
    const idxPulang = ceklokHeaders.indexOf("jam_pulang");
    const idxKetManual = ceklokHeaders.indexOf("ket_libur_manual");

    if ([idxNama, idxTanggal, idxMasuk, idxPulang, idxKetManual].includes(-1)) {
      return { success: false, error: "Header kolom di 'Ceklok_Manual' tidak lengkap." };
    }

    const excelHeaders = excelData[0].map(h => String(h).trim().toLowerCase());
    const idxExcelTgl = excelHeaders.indexOf("tanggal");
    const idxExcelMasuk = excelHeaders.indexOf("jam masuk");
    const idxExcelPulang = excelHeaders.indexOf("jam pulang");
    // **BARU**: Mencari kolom keterangan. Kita coba beberapa nama umum.
    const idxExcelKet = excelHeaders.indexOf("alasan tidak hadir") !== -1 
                        ? excelHeaders.indexOf("alasan tidak hadir") 
                        : excelHeaders.indexOf("keterangan");

    if ([idxExcelTgl, idxExcelMasuk, idxExcelPulang].includes(-1)) {
        return { success: false, error: "Format kolom di file Excel tidak sesuai. Pastikan ada kolom 'TANGGAL', 'JAM MASUK', dan 'JAM PULANG'." };
    }

    let updatedCount = 0;
    let createdCount = 0;

    // Mulai dari baris kedua data Excel (indeks 1)
    for (let i = 1; i < excelData.length; i++) {
      const row = excelData[i];
      const tanggalExcelRaw = row[idxExcelTgl];
      let jamMasukExcel = formatTimeToHHMM_or_Empty(String(row[idxExcelMasuk] || ''));
      let jamPulangExcel = formatTimeToHHMM_or_Empty(String(row[idxExcelPulang] || ''));
      // **BARU**: Ambil data keterangan dari Excel
      const keteranganExcel = (idxExcelKet !== -1 && row[idxExcelKet]) ? String(row[idxExcelKet]).trim() : '';
      
      // Skip baris jika tidak ada data sama sekali
      if (!tanggalExcelRaw && !jamMasukExcel && !jamPulangExcel && !keteranganExcel) continue;

      // **BARU**: Logika jika ada keterangan, maka jam dikosongkan
      if (keteranganExcel) {
        jamMasukExcel = '';
        jamPulangExcel = '';
      }

      // Konversi tanggal dari Excel (bisa berupa angka serial atau string)
      let tanggalObj;
      if (typeof tanggalExcelRaw === 'number') {
        tanggalObj = new Date((tanggalExcelRaw - 25569) * 86400 * 1000);
      } else if (typeof tanggalExcelRaw === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(tanggalExcelRaw)) {
        tanggalObj = new Date(tanggalExcelRaw);
      } else {
        continue; // Skip jika format tanggal tidak dikenali
      }

      // **PERBAIKAN**: Pastikan objek tanggal tidak memiliki komponen waktu (set ke awal hari)
      const dateOnlyObj = new Date(tanggalObj.getFullYear(), tanggalObj.getMonth(), tanggalObj.getDate());
      const tanggalStr = Utilities.formatDate(dateOnlyObj, Session.getScriptTimeZone(), "dd/MM/yyyy");

      // Cari baris yang cocok di sheet Ceklok_Manual
      let foundRowIndex = -1;
      for (let j = 1; j < allCeklokData.length; j++) {
        const ceklokRow = allCeklokData[j];
        if (String(ceklokRow[idxNama]).trim() === teacherName &&
            ceklokRow[idxTanggal] instanceof Date &&
            Utilities.formatDate(new Date(ceklokRow[idxTanggal]), Session.getScriptTimeZone(), "dd/MM/yyyy") === tanggalStr) {
          foundRowIndex = j + 1; // 1-based index untuk sheet
          break;
        }
      }

      if (foundRowIndex !== -1) {
        // Update baris yang sudah ada
        ceklokSheet.getRange(foundRowIndex, idxMasuk + 1).setValue(jamMasukExcel);
        ceklokSheet.getRange(foundRowIndex, idxPulang + 1).setValue(jamPulangExcel);
        ceklokSheet.getRange(foundRowIndex, idxKetManual + 1).setValue(keteranganExcel);
        updatedCount++;
      } else {
        // Tambah baris baru jika tidak ditemukan
        let newRowValues = new Array(ceklokHeaders.length).fill('');
        newRowValues[idxNama] = teacherName;
        newRowValues[idxTanggal] = dateOnlyObj; // Gunakan objek tanggal tanpa waktu
        newRowValues[idxMasuk] = jamMasukExcel;
        newRowValues[idxPulang] = jamPulangExcel;
        newRowValues[idxKetManual] = keteranganExcel;
        ceklokSheet.appendRow(newRowValues);
        createdCount++;
      }
    }
    
    // **PERBAIKAN**: Setelah loop selesai, set format kolom ke teks dan tanggal
    if (ceklokSheet.getLastRow() > 1) {
      const lastDataRow = ceklokSheet.getLastRow();
      // Format kolom tanggal ke 'dd/mm/yyyy'
      ceklokSheet.getRange(2, idxTanggal + 1, lastDataRow - 1, 1).setNumberFormat("dd/mm/yyyy");
      // Format kolom jam dan keterangan ke Teks Biasa ('@')
      ceklokSheet.getRange(2, idxMasuk + 1, lastDataRow - 1, 1).setNumberFormat("@");
      ceklokSheet.getRange(2, idxPulang + 1, lastDataRow - 1, 1).setNumberFormat("@");
      ceklokSheet.getRange(2, idxKetManual + 1, lastDataRow - 1, 1).setNumberFormat("@");
    }

    // Log aktivitas
    logUserActivity(Session.getActiveUser().getEmail(), 'admin', 'IMPORT_EXCEL_SUCCESS', teacherName, `Data diperbarui: ${updatedCount}, Data baru dibuat: ${createdCount}`, 'SUCCESS');

    return { success: true, message: `Impor berhasil. Data diperbarui: ${updatedCount}, Data baru ditambahkan: ${createdCount}.` };

  } catch (e) {
    Logger.log(`Error di importFromExcel (guru: ${teacherName}): ${e.toString()}\nStack: ${e.stack}`);
    logUserActivity(Session.getActiveUser().getEmail(), 'admin', 'IMPORT_EXCEL_ERROR', teacherName, e.message, 'ERROR');
    return { success: false, error: `Gagal mengimpor data: ${e.message}` };
  }
}
